---
icon: akar-icons:file
date: 2025-08-21
order: 5
category:
  - Function
---

# 撤回重做-命令模式

## 定义命令接口

```typescript

/**
 * 命令定义接口
 */
export interface Command<T = any> {
    id: number
    label: string
    // 校验模块
    validateModelSet: Set<BaseMode>
    // 执行
    execute: (recordCommand: boolean) => CommandResult
    doExecute: () => CommandResult
    // 重做
    redo: () => CommandResult
    // 撤回
    undo: () => CommandResult
}
```

## 抽象命令

```typescript
/**
 * 命令抽象实现
 */
export abstract class AbstractCommand<T = any> implements Command<T> {
    public id: number
    public label: string

    protected constructor(id: number, label: string) {
        this.id = id
        this.label = label
    }

    /**
     *  重做, 重写实现定制逻辑
     */

    public redo(): CommandResult {
        return this.doExecute()
    }

    /**
     *  撤销, 重写实现定制逻辑
     */
    abstract undo(): CommandResult

    /**
     * 供execute()调用, 重写实现定制逻辑
     */
    abstract doExecute(): CommandResult

    /**
     * 命令调用并记录命令到命令栈中
     */
    public execute(recordCommand = true): CommandResult {
        this.recordLocation()
        const doExecuteResult = this.doExecute()
        recordCommand && this.app.commandManage.recordCommand(this)
        return doExecuteResult
    }
}
```

## 命令管理中心

```typescript
/**
 * 命令管理器接口
 */
export interface ICommandManage {
    /**
     * 当前最近一次执行的操作的标识id
     */
    getActiveCommandId(): UndefinedAble<number>

    /**
     * 获取历史操作
     */
    getHistory(): Command[]

    /**
     * 重做
     */
    next(): void

    /**
     * 撤回
     */
    back(): void

    /**
     * 撤销或重做到对应的操作记录
     */
    gotoCommand(targetCommandId: number): void

    /**
     * 记录操作
     * @param command 操作对象
     */
    recordCommand(command: Command): void


}

export class CommandManage implements ICommandManage {
    // 操作栈
    private commandStack: Command[] = []
    // 当前最近一次执行的操作
    private activeCommand?: Command
    // 最大记录数
    private maxStack = 50

    private eventBus: EventBus = new EventBus()

    /**
     * 当前最近一次执行的操作的标识id
     */
    public getActiveCommandId(): UndefinedAble<number> {
        return this.activeCommand?.id
    }

    /**
     * 获取历史操作
     */
    public getHistory(): Command[] {
        return this.commandStack
    }

    /**
     * 重做
     */
    public next(): void {
        const index = this.commandStack.findIndex(it => it.id === this.getActiveCommandId())
        // 可执行条件 当前的命令不在命令栈末尾或者没有当前命令但命令栈中存在命令
        if (index > -1 && index < this.commandStack.length - 1) {
            this.gotoCommand(this.commandStack[index + 1].id)
        } else if (index === -1 && this.commandStack.length) {
            this.gotoCommand(this.commandStack[0].id)
        }
    }

    /**
     * 撤回
     */
    public back(): void {
        const activeCommandId = this.getActiveCommandId()
        if (activeCommandId) {
            this.gotoCommand(activeCommandId)
        }
    }

    /**
     * 撤销或重做到对应的操作记录
     */
    public gotoCommand(targetCommandId: number): void {
        const targetCommand = this.commandStack.find(item => item.id === targetCommandId)
        if (!targetCommand) return
        const targetIndex = this.commandStack.findIndex(item => item.id === targetCommandId)
        const commandResults = []
        const prevCommandId = this.getActiveCommandId()
        if (!prevCommandId) {
            // 从上一次操作依次重做到目标操作
            for (let i = 0; i <= targetIndex; i++) {
                const commandResult = this.commandStack[i].redo()
                commandResults.push(commandResult)
            }
            this.activeCommand = targetCommand
        } else {
            const prevIndex = this.commandStack.findIndex(item => item.id === prevCommandId)
            if (prevIndex >= targetIndex) {
                // 从上一次操作依次撤回到目标操作
                for (let i = prevIndex; i >= targetIndex; i--) {
                    const commandResult = this.commandStack[i].undo()
                    commandResults.push(commandResult)
                    // 撤回时activeCommand为 撤回目标的上一个命令
                    this.activeCommand = targetIndex ? this.commandStack[targetIndex - 1] : undefined
                }
            } else {
                // 从上一次操作依次重做到目标操作
                for (let i = prevIndex + 1; i <= targetIndex; i++) {
                    const commandResult = this.commandStack[i].redo()
                    commandResults.push(commandResult)
                }
                this.activeCommand = targetCommand
            }
        }
        // todo 撤销和重做时保存数据
    }

    /**
     * 记录操作
     * @param command 操作对象
     */
    public recordCommand(command: Command): void {
        if (this.commandStack.length > 0) {
            const currentIndex = this.commandStack.findIndex(item => item.id === this.getActiveCommandId())
            if (currentIndex + 1 === this.commandStack.length && currentIndex + 1 >= this.maxStack) {
                // 当前指针在栈尾, 并且栈容量放满了
                // 栈超出限制移除最老的数据
                this.commandStack.shift()
            }
            if (this.commandStack.length - 1 > currentIndex) {
                // 添加新的操作会覆盖已撤销的操作
                // 添加新操作维护local操作状态使count永不为0
                countNeverZero(this.maxStack + 1)
                this.commandStack.splice(currentIndex + 1)
            }
        }
        // 追加记录
        this.commandStack.push(command)
        this.activeCommand = command
    }
}

```

