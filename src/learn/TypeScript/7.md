---
icon: akar-icons:file
date: 2025-08-19
order: 7
category:
  - TypeScript
---

# tsconfig.json

## 简介

`tsconfig.json`是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有`tsconfig.json`，**TypeScript 就认为这是项目的根目录**。
`tsconfig.json`文件主要供tsc编译器使用，它的命令行参数`--project`或`-p`可以指定`tsconfig.json`的位置

```bash
tsc -p ./dir
```

## 基本结构

`tsconfig.json`文件可以不必手写，使用 `tsc` 命令的`--init`参数自动生成。
::: tip
你也可以使用别人预先写好的 `tsconfig.json` 文件，`npm` 的`@tsconfig`名称空间下面有很多模块，都是写好的`tsconfig.json`样本，比如 `@tsconfig/recommended`和`@tsconfig/node16`
::: code-tabs#shell
@tab npm

```bash :no-line-numbers
npm install --save-dev @tsconfig/deno
```

@tab yarn

```bash :no-line-numbers
yarn add --dev @tsconfig/deno
```

安装以后，就可以在`tsconfig.json`里面引用这个模块，相当于继承它的设置，然后进行扩展

```json :no-line-numbers
{
  "extends": "@tsconfig/deno/tsconfig.json"
}
```

:::

### compilerOptions

#### allowJs

`allowJs`允许 `TypeScript` 项目加载 JS 脚本。编译时，也会将 JS 文件，一起拷贝到输出目录

```json :no-line-numbers
{
  "compilerOptions": {
    "allowJs": true
  }
}
```

#### alwaysStrict

`alwaysStrict`确保脚本以 `ECMAScript` 严格模式进行解析，因此脚本头部不用写`"use strict"`。它的值是一个布尔值，默认为`true`。

#### allowSyntheticDefaultImports

`allowSyntheticDefaultImports`允许`import`命令默认加载没有`default`输出的模块。

比如，打开这个设置，就可以写`import React from "react";`，而不是`import * as React from "react"`;

#### allowUnreachableCode

`allowUnreachableCode`设置是否允许存在不可能执行到的代码。它的值有三种可能

- `undefined`： 默认值，编辑器显示警告。
- `true`：忽略不可能执行到的代码。
- `false`：编译器报错。

#### allowUnusedLabels

`allowUnusedLabels`设置是否允许存在未使用的标签。它的值有三种可能

- `undefined`： 默认值，编辑器显示警告。
- `true`：忽略未使用的标签。
- `false`：编译器报错。

#### baseUrl

`baseUrl`的值为字符串，指定 TypeScript 项目的基准目录。
由于默认是以 `tsconfig.json` 的位置作为基准目录，所以一般情况不需要使用该属性。

```json
{
  "compilerOptions": {
    "baseUrl": "./"
  }
}
```

上面示例中，`baseUrl`为当前目录`./`。那么，当遇到下面的语句，TypeScript 将以`./`为起点，寻找`hello/world.ts`。

#### checkJs

`checkJS`设置对 JS 文件同样进行类型检查。打开这个属性，也会自动打开`allowJs`。它等同于在 JS 脚本的头部添加`// @ts-check`命令。

#### composite

`composite`打开某些设置，使得 TypeScript 项目可以进行增量构建，往往跟`incremental`属性配合使用。

#### declaration

`declaration`设置编译时是否为每个脚本生成类型声明文件`.d.ts`。

#### declarationDir

`declarationDir`设置生成的`.d.ts`文件所在的目录。

```json :no-line-numbers
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "./types"
  }
}
```

#### declarationMap

`declarationMap`设置生成`.d.ts`类型声明文件的同时，还会生成对应的 `Source Map` 文件。

```json :no-line-numbers
{
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true
  }
}
```

#### diagnostics

显示诊断信息

#### disableSizeLimit

禁用JavaScript工程体积大小的限制

#### emitBOM

`emitBOM`设置是否在编译结果的文件头添加字节顺序标志 BOM，默认值是`false`

#### emitDecoratorMetadata[实验性]

给源码里的装饰器声明加上设计类型元数据。

#### experimentalDecorators[实验性]

启用实验性的ES装饰器。

#### emitDeclarationOnly

`emitDeclarationOnly`设置编译后只生成`.d.ts`文件，不生成`.js`文件

#### extendedDiagnostics

显示详细的诊断信息

#### esModuleInterop

`esModuleInterop`修复了一些 CommonJS 和 ES6 模块之间的兼容性问题。

如果`module`属性为`node16`或`nodenext`，则`esModuleInterop`默认为`true`，其他情况默认为`false`。

打开这个属性，使用import命令加载 CommonJS 模块时，TypeScript 会严格检查兼容性问题是否存在。

```typescript :no-line-numbers
import * as moment from "moment";

moment(); // 报错
```

上面示例中，根据 ES6 规范，`import * as moment`里面的`moment`是一个对象，不能当作函数调用，所以第二行报错了。

解决方法就是改写上面的语句，改成加载默认接口。

```typescript :no-line-numbers
import moment from "moment";

moment(); // 不报错
```

打开`esModuleInterop`以后，如果将上面的代码编译成 CommonJS 模块格式，就会加入一些辅助函数，保证编译后的代码行为正确。
::: tip
注意，打开`esModuleInterop`，将自动打开`allowSyntheticDefaultImports`。
:::

#### exactOptionalPropertyTypes

`exactOptionalPropertyTypes`设置可选属性不能赋值为`undefined`。

```typescript :no-line-numbers
// 打开 exactOptionalPropertyTypes
interface MyObj {
    foo?: "A" | "B";
}

let obj: MyObj = {foo: "A"};

obj.foo = undefined; // 报错
```

上面示例中，foo是可选属性，打开exactOptionalPropertyTypes以后，该属性就不能显式赋值为undefined。

#### forceConsistentCasingInFileNames

`forceConsistentCasingInFileNames`设置文件名是否为大小写敏感，默认为`true`

#### incremental

`incremental`让 TypeScript 项目构建时产生文件`tsbuildinfo`，从而完成增量构建

#### inlineSourceMap

`inlineSourceMap`设置将 SourceMap 文件写入编译后的 JS 文件中，否则会单独生成一个`.js.map`文件。

#### inlineSources

`inlineSources`设置将原始的`.ts`代码嵌入编译后的 JS 中。

它要求`sourceMap`或`inlineSourceMap`至少打开一个。

#### isolatedModules

`isolatedModules`设置如果当前 TypeScript 脚本作为单个模块编译，是否会因为缺少其他脚本的类型信息而报错，主要便于非官方的编译工具（比如 Babel）正确编译单个脚本。

#### jsx

`jsx`设置如何处理`.tsx`文件。它一般以下三个值。

- `preserve`：保留JSX语法，输出的文件名为 jsx。
- `react`：将<div />编译成React.createElement("div")，输出的文件名为.js
- `react-native`：将<div />编译成React.createElement("div")，输出的文件名为.js，支持JSX转换。

```json :no-line-numbers
{
  "compilerOptions": {
    "jsx": "preserve"
  }
}
```

#### lib

`lib`值是一个数组，描述项目需要加载的 TypeScript 内置类型描述文件，跟三斜线指令`/// <reference lib="" />`作用相同。

```json
{
  "compilerOptions": {
    "lib": [
      "dom",
      "es2021"
    ]
  }
}
```

#### listEmittedFiles

`listEmittedFiles`设置编译时在终端显示，生成了哪些文件。

```json
{
  "compilerOptions": {
    "listEmittedFiles": true
  }
}
```

#### listFiles

listFiles设置编译时在终端显示，参与本次编译的文件列表。

```json
{
  "compilerOptions": {
    "listFiles": true
  }
}
```

#### mapRoot

`mapRoot`指定 SourceMap 文件的位置，而不是默认的生成位置。

```json
{
  "compilerOptions": {
    "sourceMap": true,
    "mapRoot": "https://my-website.com/debug/sourcemaps/"
  }
}
```

#### module

`module`指定编译产物的模块格式。它的默认值与`target`属性有关，如果`target`是`ES3`或`ES5`，它的默认值是`commonjs`，否则就是`ES6/ES2015`。

#### moduleResolution

`moduleResolution`确定模块路径的算法，即如何查找模块。它可以取以下四种值。

- `node`：采用 Node.js 的 CommonJS 模块算法。
- `node16`或`nodenext`：采用 Node.js 的 ECMAScript 模块算法，从 TypeScript 4.7 开始支持。
- `classic`：TypeScript 1.6 之前的算法，新项目不建议使用。

它的默认值与`module`属性有关，如果`module`为`AMD`、`UMD`、`System`或`ES6/ES2015`，默认值为`classic`；如果`module`为`node16`或n`odenext`，默认值为这两个值；其他情况下,默认值为`Node`。

#### moduleSuffixes

`moduleSuffixes`指定模块的后缀名。

```json
{
  "compilerOptions": {
    "moduleSuffixes": [
      ".ios",
      ".native",
      ""
    ]
  }
}
```

上面的设置使得 TypeScript 对于语句`import * as foo from "./foo";`，会搜索以下脚本`./foo.ios.ts`、`./foo.native.ts`和`./foo.ts`。

#### newLine

`newLine`设置换行符为`CRLF（Windows）`还是`LF（Linux）`。

#### noEmit

`noEmit`设置是否产生编译结果。如果不生成，TypeScript 编译就纯粹作为类型检查了。

#### noEmitHelpers

`noEmitHelpers`设置在编译结果文件不插入 TypeScript 辅助函数，而是通过外部引入辅助函数来解决，比如 `NPM `模块`tslib`。

### exclude

exclude属性是一个数组，必须与include属性一起使用，用来从编译列表中去除指定的文件。它也支持使用与include属性相同的通配符。

- include: 指定要包含在编译中的文件或目录，支持通配符
- exclude: 指定要排除在编译之外的文件或目录，默认排除node_modules、dist等

```json :no-line-numbers
{
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}

```

### include

include属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。

```json :no-line-numbers
{
  "include": [
    "src/**/*",
    "tests/**/*"
  ]
}
```

**`include`属性支持三种通配符**

- `?`：指代单个字符
- `*`：指代任意字符，不含路径分隔符
- `**`：指定任意目录层级。

如果不指定文件后缀名，默认包括.ts、.tsx和.d.ts文件。如果打开了allowJs，那么还包括.js和.jsx。

### extends

`tsconfig.json`可以继承另一个`tsconfig.json`文件的配置。如果一个项目有多个配置，可以把共同的配置写成`tsconfig.base.json`，其他的配置文件继承该文件，这样便于维护和修改。

`extends`属性用来指定所要继承的配置文件。它可以是本地文件。
::: code-tabs#shell
@tab 本地文件

```json :no-line-numbers
{
  "extends": "./tsconfig.base.json"
}
```

@tab npm模块

```json :no-line-numbers
{
  "extends": "@tsconfig/node12/tsconfig.json"
}
```

:::

### references

`reference`s属性是一个数组，数组成员为对象，适合一个大项目由许多小项目构成的情况，用来设置需要引用的底层项目。

```json :no-line-numbers
{
  "references": [
    {
      "path": "../pkg1"
    },
    {
      "path": "../pkg2/tsconfig.json"
    }
  ]
}
```

### files

`files`属性指定编译的文件列表，如果其中有一个文件不存在，就会报错。

它是一个数组，排在前面的文件先编译。

```json :no-line-numbers
{
  "files": [
    "a.ts",
    "b.ts"
  ]
}
```

::: warning
该属性必须逐一列出文件，不支持文件匹配。如果文件较多，建议使用`include`和`exclude`属性。
:::


