/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function xt(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const Ot={},St=()=>{},ze=Object.assign,It=Object.prototype.hasOwnProperty,se=(e,t)=>It.call(e,t),z=Array.isArray,Y=e=>Ve(e)==="[object Map]",oe=e=>typeof e=="function",Ce=e=>typeof e=="string",L=e=>typeof e=="symbol",B=e=>e!==null&&typeof e=="object",Nt=Object.prototype.toString,Ve=e=>Nt.call(e),ke=e=>Ve(e).slice(8,-1),ie=e=>Ce(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Mt=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},Ln=Mt(e=>e.charAt(0).toUpperCase()+e.slice(1)),W=(e,t)=>!Object.is(e,t);let $e;const ce=()=>$e||($e=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Rt(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let Tt,je=0,ae;function ue(){je++}function le(){if(--je>0)return;let e;for(;ae;){let t=ae;for(ae=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}let G=!0;const De=[];function fe(){De.push(G),G=!1}function de(){const e=De.pop();G=e===void 0?!0:e}class Fe{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){}trigger(t){this.version++,this.notify(t)}notify(t){ue();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{le()}}}const he=new WeakMap,C=Symbol(""),pe=Symbol(""),H=Symbol("");function E(e,t,n){if(G&&Tt){let s=he.get(e);s||he.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new Fe),r.map=s,r.key=n),r.track()}}function I(e,t,n,s,r,o){const i=he.get(e);if(!i)return;const c=a=>{a&&a.trigger()};if(ue(),t==="clear")i.forEach(c);else{const a=z(e),u=a&&ie(n);if(a&&n==="length"){const l=Number(s);i.forEach((f,d)=>{(d==="length"||d===H||!L(d)&&d>=l)&&c(f)})}else switch((n!==void 0||i.has(void 0))&&c(i.get(n)),u&&c(i.get(H)),t){case"add":a?u&&c(i.get("length")):(c(i.get(C)),Y(e)&&c(i.get(pe)));break;case"delete":a||(c(i.get(C)),Y(e)&&c(i.get(pe)));break;case"set":Y(e)&&c(i.get(C));break}}le()}function $(e){const t=p(e);return t===e?t:(E(t,"iterate",H),N(e)?t:t.map(v))}function ge(e){return E(e=p(e),"iterate",H),e}const zt={__proto__:null,[Symbol.iterator](){return _e(this,Symbol.iterator,v)},concat(...e){return $(this).concat(...e.map(t=>z(t)?$(t):t))},entries(){return _e(this,"entries",e=>(e[1]=v(e[1]),e))},every(e,t){return O(this,"every",e,t,void 0,arguments)},filter(e,t){return O(this,"filter",e,t,n=>n.map(v),arguments)},find(e,t){return O(this,"find",e,t,v,arguments)},findIndex(e,t){return O(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return O(this,"findLast",e,t,v,arguments)},findLastIndex(e,t){return O(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return O(this,"forEach",e,t,void 0,arguments)},includes(...e){return me(this,"includes",e)},indexOf(...e){return me(this,"indexOf",e)},join(e){return $(this).join(e)},lastIndexOf(...e){return me(this,"lastIndexOf",e)},map(e,t){return O(this,"map",e,t,void 0,arguments)},pop(){return K(this,"pop")},push(...e){return K(this,"push",e)},reduce(e,...t){return Pe(this,"reduce",e,t)},reduceRight(e,...t){return Pe(this,"reduceRight",e,t)},shift(){return K(this,"shift")},some(e,t){return O(this,"some",e,t,void 0,arguments)},splice(...e){return K(this,"splice",e)},toReversed(){return $(this).toReversed()},toSorted(e){return $(this).toSorted(e)},toSpliced(...e){return $(this).toSpliced(...e)},unshift(...e){return K(this,"unshift",e)},values(){return _e(this,"values",v)}};function _e(e,t,n){const s=ge(e),r=s[t]();return s!==e&&!N(e)&&(r._next=r.next,r.next=()=>{const o=r._next();return o.value&&(o.value=n(o.value)),o}),r}const Ct=Array.prototype;function O(e,t,n,s,r,o){const i=ge(e),c=i!==e&&!N(e),a=i[t];if(a!==Ct[t]){const f=a.apply(e,o);return c?v(f):f}let u=n;i!==e&&(c?u=function(f,d){return n.call(this,v(f),d,e)}:n.length>2&&(u=function(f,d){return n.call(this,f,d,e)}));const l=a.call(i,u,s);return c&&r?r(l):l}function Pe(e,t,n,s){const r=ge(e);let o=n;return r!==e&&(N(e)?n.length>3&&(o=function(i,c,a){return n.call(this,i,c,a,e)}):o=function(i,c,a){return n.call(this,i,v(c),a,e)}),r[t](o,...s)}function me(e,t,n){const s=p(e);E(s,"iterate",H);const r=s[t](...n);return(r===-1||r===!1)&&Jt(n[0])?(n[0]=p(n[0]),s[t](...n)):r}function K(e,t,n=[]){fe(),ue();const s=p(e)[t].apply(e,n);return le(),de(),s}const Vt=xt("__proto__,__v_isRef,__isVue"),Ae=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(L));function kt(e){L(e)||(e=String(e));const t=p(this);return E(t,"has",e),t.hasOwnProperty(e)}class Le{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,o=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return o;if(n==="__v_raw")return s===(r?o?Kt:Ke:o?Ht:He).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const i=z(t);if(!r){let a;if(i&&(a=zt[n]))return a;if(n==="hasOwnProperty")return kt}const c=Reflect.get(t,n,V(t)?t:s);return(L(n)?Ae.has(n):Vt(n))||(r||E(t,"get",n),o)?c:V(c)?i&&ie(n)?c:c.value:B(c)?r?Ue(c):qe(c):c}}class $t extends Le{constructor(t=!1){super(!1,t)}set(t,n,s,r){let o=t[n];if(!this._isShallow){const a=j(o);if(!N(s)&&!j(s)&&(o=p(o),s=p(s)),!z(t)&&V(o)&&!V(s))return a?!1:(o.value=s,!0)}const i=z(t)&&ie(n)?Number(n)<t.length:se(t,n),c=Reflect.set(t,n,s,V(t)?t:r);return t===p(r)&&(i?W(s,o)&&I(t,"set",n,s,o):I(t,"add",n,s)),c}deleteProperty(t,n){const s=se(t,n),r=t[n],o=Reflect.deleteProperty(t,n);return o&&s&&I(t,"delete",n,void 0,r),o}has(t,n){const s=Reflect.has(t,n);return(!L(n)||!Ae.has(n))&&E(t,"has",n),s}ownKeys(t){return E(t,"iterate",z(t)?"length":C),Reflect.ownKeys(t)}}class jt extends Le{constructor(t=!1){super(!0,t)}set(t,n){return!0}deleteProperty(t,n){return!0}}const Dt=new $t,Ft=new jt,ye=e=>e,Q=e=>Reflect.getPrototypeOf(e);function Pt(e,t,n){return function(...s){const r=this.__v_raw,o=p(r),i=Y(o),c=e==="entries"||e===Symbol.iterator&&i,a=e==="keys"&&i,u=r[e](...s),l=n?ye:t?we:v;return!t&&E(o,"iterate",a?pe:C),{next(){const{value:f,done:d}=u.next();return d?{value:f,done:d}:{value:c?[l(f[0]),l(f[1])]:l(f),done:d}},[Symbol.iterator](){return this}}}}function X(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function At(e,t){const n={get(r){const o=this.__v_raw,i=p(o),c=p(r);e||(W(r,c)&&E(i,"get",r),E(i,"get",c));const{has:a}=Q(i),u=t?ye:e?we:v;if(a.call(i,r))return u(o.get(r));if(a.call(i,c))return u(o.get(c));o!==i&&o.get(r)},get size(){const r=this.__v_raw;return!e&&E(p(r),"iterate",C),Reflect.get(r,"size",r)},has(r){const o=this.__v_raw,i=p(o),c=p(r);return e||(W(r,c)&&E(i,"has",r),E(i,"has",c)),r===c?o.has(r):o.has(r)||o.has(c)},forEach(r,o){const i=this,c=i.__v_raw,a=p(c),u=t?ye:e?we:v;return!e&&E(a,"iterate",C),c.forEach((l,f)=>r.call(o,u(l),u(f),i))}};return ze(n,e?{add:X("add"),set:X("set"),delete:X("delete"),clear:X("clear")}:{add(r){!t&&!N(r)&&!j(r)&&(r=p(r));const o=p(this);return Q(o).has.call(o,r)||(o.add(r),I(o,"add",r,r)),this},set(r,o){!t&&!N(o)&&!j(o)&&(o=p(o));const i=p(this),{has:c,get:a}=Q(i);let u=c.call(i,r);u||(r=p(r),u=c.call(i,r));const l=a.call(i,r);return i.set(r,o),u?W(o,l)&&I(i,"set",r,o,l):I(i,"add",r,o),this},delete(r){const o=p(this),{has:i,get:c}=Q(o);let a=i.call(o,r);a||(r=p(r),a=i.call(o,r));const u=c?c.call(o,r):void 0,l=o.delete(r);return a&&I(o,"delete",r,void 0,u),l},clear(){const r=p(this),o=r.size!==0,i=void 0,c=r.clear();return o&&I(r,"clear",void 0,void 0,i),c}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=Pt(r,e,t)}),n}function We(e,t){const n=At(e,t);return(s,r,o)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?s:Reflect.get(se(n,r)&&r in s?n:s,r,o)}const Lt={get:We(!1,!1)},Wt={get:We(!0,!1)};function Wn(e,t,n){const s=p(n);if(s!==n&&t.call(e,s)){const r=ke(e);Rt(`Reactive ${r} contains both the raw and reactive versions of the same object${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const He=new WeakMap,Ht=new WeakMap,Ke=new WeakMap,Kt=new WeakMap;function qt(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Ut(e){return e.__v_skip||!Object.isExtensible(e)?0:qt(ke(e))}function qe(e){return j(e)?e:Je(e,!1,Dt,Lt,He)}function Ue(e){return Je(e,!0,Ft,Wt,Ke)}function Je(e,t,n,s,r){if(!B(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=Ut(e);if(o===0)return e;const i=r.get(e);if(i)return i;const c=new Proxy(e,o===2?s:n);return r.set(e,c),c}function j(e){return!!(e&&e.__v_isReadonly)}function N(e){return!!(e&&e.__v_isShallow)}function Jt(e){return e?!!e.__v_raw:!1}function p(e){const t=e&&e.__v_raw;return t?p(t):e}const v=e=>B(e)?qe(e):e,we=e=>B(e)?Ue(e):e;function V(e){return e?e.__v_isRef===!0:!1}function Yt(e){return Bt(e,!1)}function Bt(e,t){return V(e)?e:new Gt(e,t)}class Gt{constructor(t,n){this.dep=new Fe,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:p(t),this._value=n?t:v(t),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(t){const n=this._rawValue,s=this.__v_isShallow||N(t)||j(t);t=s?t:p(t),W(t,n)&&(this._rawValue=t,this._value=s?t:v(t),this.dep.trigger())}}/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const k=[];function Hn(e){k.push(e)}function Kn(){k.pop()}let be=!1;function qn(e,...t){if(be)return;be=!0,fe();const n=k.length?k[k.length-1].component:null,s=n&&n.appContext.config.warnHandler,r=Qt();if(s)ve(s,n,11,[e+t.map(o=>{var i,c;return(c=(i=o.toString)==null?void 0:i.call(o))!=null?c:JSON.stringify(o)}).join(""),n&&n.proxy,r.map(({vnode:o})=>`at <${et(n,o.type)}>`).join(`
`),r]);else{const o=[`[Vue warn]: ${e}`,...t];r.length&&o.push(`
`,...Xt(r)),console.warn(...o)}de(),be=!1}function Qt(){let e=k[k.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const s=e.component&&e.component.parent;e=s&&s.vnode}return t}function Xt(e){const t=[];return e.forEach((n,s)=>{t.push(...s===0?[]:[`
`],...Zt(n))}),t}function Zt({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"",s=e.component?e.component.parent==null:!1,r=` at <${et(e.component,e.type,s)}`,o=">"+n;return e.props?[r,...en(e.props),o]:[r+o]}function en(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(s=>{t.push(...Ye(s,e[s]))}),n.length>3&&t.push(" ..."),t}function Ye(e,t,n){return Ce(t)?(t=JSON.stringify(t),n?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[`${e}=${t}`]:V(t)?(t=Ye(e,p(t.value),!0),n?t:[`${e}=Ref<`,t,">"]):oe(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=p(t),n?t:[`${e}=`,t])}const Un={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function ve(e,t,n,s){try{return s?e(...s):e()}catch(r){Be(r,t,n)}}function Be(e,t,n,s=!0){const r=t?t.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||Ot;if(t){let c=t.parent;const a=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;c;){const l=c.ec;if(l){for(let f=0;f<l.length;f++)if(l[f](e,a,u)===!1)return}c=c.parent}if(o){fe(),ve(o,null,10,[e,a,u]),de();return}}tn(e,n,r,s,i)}function tn(e,t,n,s=!0,r=!1){if(r)throw e;console.error(e)}const x=[];let S=-1;const D=[];let M=null,F=0;const nn=Promise.resolve();let Ee=null;const rn=100;function sn(e){let t=S+1,n=x.length;for(;t<n;){const s=t+n>>>1,r=x[s],o=q(r);o<e||o===e&&r.flags&2?t=s+1:n=s}return t}function on(e){if(!(e.flags&1)){const t=q(e),n=x[x.length-1];!n||!(e.flags&2)&&t>=q(n)?x.push(e):x.splice(sn(t),0,e),e.flags|=1,Ge()}}function Ge(){Ee||(Ee=nn.then(Qe))}function cn(e){z(e)?D.push(...e):M&&e.id===-1?M.splice(F+1,0,e):e.flags&1||(D.push(e),e.flags|=1),Ge()}function an(e){if(D.length){const t=[...new Set(D)].sort((n,s)=>q(n)-q(s));if(D.length=0,M){M.push(...t);return}for(M=t,F=0;F<M.length;F++){const n=M[F];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}M=null,F=0}}const q=e=>e.id==null?e.flags&2?-1:1/0:e.id;function Qe(e){const t=St;try{for(S=0;S<x.length;S++){const n=x[S];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),ve(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;S<x.length;S++){const n=x[S];n&&(n.flags&=-2)}S=-1,x.length=0,an(e),Ee=null,(x.length||D.length)&&Qe(e)}}function Jn(e,t){const n=e.get(t)||0;if(n>rn){const s=t.i,r=s&&Ze(s.type);return Be(`Maximum recursive updates exceeded${r?` in component <${r}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return e.set(t,n+1),!1}const xe=new Map,Z=new Map;function Yn(e,t){return Z.has(e)?!1:(Z.set(e,{initialDef:ee(t),instances:new Set}),!0)}function ee(e){return fn(e)?e.__vccOpts:e}function Bn(e,t){const n=Z.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(s=>{t&&(s.render=t,ee(s.type).render=t),s.renderCache=[],s.update()}))}function Gn(e,t){const n=Z.get(e);if(!n)return;t=ee(t),Xe(n.initialDef,t);const s=[...n.instances];for(let r=0;r<s.length;r++){const o=s[r],i=ee(o.type);let c=xe.get(i);c||(i!==n.initialDef&&Xe(i,t),xe.set(i,c=new Set)),c.add(o),o.appContext.propsCache.delete(o.type),o.appContext.emitsCache.delete(o.type),o.appContext.optionsCache.delete(o.type),o.ceReload?(c.add(o),o.ceReload(t.styles),c.delete(o)):o.parent?on(()=>{o.parent.update(),c.delete(o)}):o.appContext.reload?o.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),o.root.ce&&o!==o.root&&o.root.ce._removeChildStyle(i)}cn(()=>{xe.clear()})}function Xe(e,t){ze(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Qn(e){return(t,n)=>{try{return e(t,n)}catch(s){console.error(s),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}ce().requestIdleCallback,ce().cancelIdleCallback;const Xn={};{const e=ce(),t=(n,s)=>{let r;return(r=e[n])||(r=e[n]=[]),r.push(s),o=>{r.length>1?r.forEach(i=>i(o)):r[0](o)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}const un=/(?:^|[-_])(\w)/g,ln=e=>e.replace(un,t=>t.toUpperCase()).replace(/[-_]/g,"");function Ze(e,t=!0){return oe(e)?e.displayName||e.name:e.name||t&&e.__name}function et(e,t,n=!1){let s=Ze(t);if(!s&&t.__file){const r=t.__file.match(/([^/\\]+)\.\w+$/);r&&(s=r[1])}if(!s&&e&&e.parent){const r=o=>{for(const i in o)if(o[i]===t)return i};s=r(e.components||e.parent.type.components)||r(e.appContext.components)}return s?ln(s):n?"App":"Anonymous"}function fn(e){return oe(e)&&"__vccOpts"in e}const tt=()=>document.documentElement.getAttribute("data-theme")==="dark";[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:dn}=Object,{fromEntries:hn}=Object,nt=Yt(!1);typeof document<"u"&&(nt.value=tt(),new MutationObserver(()=>{nt.value=tt()}).observe(document.documentElement,{attributeFilter:["data-theme"],attributes:!0}));const pn="ENTRIES",rt="KEYS",st="VALUES",w="";class Oe{set;_type;_path;constructor(t,n){const s=t._tree,r=Array.from(s.keys());this.set=t,this._type=n,this._path=r.length>0?[{node:s,keys:r}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:n}=P(this._path);if(P(n)===w)return{done:!1,value:this.result()};const s=t.get(P(n));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=P(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>P(t)).filter(t=>t!==w).join("")}value(){return P(this._path).node.get(w)}result(){switch(this._type){case st:return this.value();case rt:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const P=e=>e[e.length-1],gn=(e,t,n)=>{const s=new Map;if(typeof t!="string")return s;const r=t.length+1,o=r+n,i=new Uint8Array(o*r).fill(n+1);for(let c=0;c<r;++c)i[c]=c;for(let c=1;c<o;++c)i[c*r]=c;return ot(e,t,n,s,i,1,r,""),s},ot=(e,t,n,s,r,o,i,c)=>{const a=o*i;e:for(const u of e.keys())if(u===w){const l=r[a-1];l<=n&&s.set(c,[e.get(u),l])}else{let l=o;for(let f=0;f<u.length;++f,++l){const d=u[f],m=i*l,b=m-i;let g=r[m];const h=Math.max(0,l-n-1),_=Math.min(i-1,l+n);for(let y=h;y<_;++y){const R=d!==t[y],re=r[b+y]+ +R,J=r[b+y+1]+1,T=r[m+y]+1,A=r[m+y+1]=Math.min(re,J,T);A<g&&(g=A)}if(g>n)continue e}ot(e.get(u),t,n,s,r,l,i,c+u)}};let it=class U{_tree;_prefix;_size=void 0;constructor(t=new Map,n=""){this._tree=t,this._prefix=n}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[n,s]=te(this._tree,t.slice(this._prefix.length));if(n===void 0){const[r,o]=Ne(s);for(const i of r.keys())if(i!==w&&i.startsWith(o)){const c=new Map;return c.set(i.slice(o.length),r.get(i)),new U(c,t)}}return new U(n,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,_n(this._tree,t)}entries(){return new Oe(this,pn)}forEach(t){for(const[n,s]of this)t(n,s,this)}fuzzyGet(t,n){return gn(this._tree,t,n)}get(t){const n=Se(this._tree,t);return n!==void 0?n.get(w):void 0}has(t){return Se(this._tree,t)?.has(w)??!1}keys(){return new Oe(this,rt)}set(t,n){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,Ie(this._tree,t).set(w,n),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Ie(this._tree,t);return s.set(w,n(s.get(w))),this}fetch(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Ie(this._tree,t);let r=s.get(w);return r===void 0&&s.set(w,r=n()),r}values(){return new Oe(this,st)}[Symbol.iterator](){return this.entries()}static from(t){const n=new U;for(const[s,r]of t)n.set(s,r);return n}static fromObject(t){return U.from(Object.entries(t))}};const te=(e,t,n=[])=>{if(t.length===0||e==null)return[e,n];for(const s of e.keys())if(s!==w&&t.startsWith(s))return n.push([e,s]),te(e.get(s),t.slice(s.length),n);return n.push([e,t]),te(void 0,"",n)},Se=(e,t)=>{if(t.length===0||!e)return e;for(const n of e.keys())if(n!==w&&t.startsWith(n))return Se(e.get(n),t.slice(n.length))},Ie=(e,t)=>{const n=t.length;e:for(let s=0;e&&s<n;){for(const o of e.keys())if(o!==w&&t[s]===o[0]){const i=Math.min(n-s,o.length);let c=1;for(;c<i&&t[s+c]===o[c];)++c;const a=e.get(o);if(c===o.length)e=a;else{const u=new Map;u.set(o.slice(c),a),e.set(t.slice(s,s+c),u),e.delete(o),e=u}s+=c;continue e}const r=new Map;return e.set(t.slice(s),r),r}return e},_n=(e,t)=>{const[n,s]=te(e,t);if(n!==void 0){if(n.delete(w),n.size===0)ct(s);else if(n.size===1){const[r,o]=n.entries().next().value;at(s,r,o)}}},ct=e=>{if(e.length===0)return;const[t,n]=Ne(e);if(t.delete(n),t.size===0)ct(e.slice(0,-1));else if(t.size===1){const[s,r]=t.entries().next().value;s!==w&&at(e.slice(0,-1),s,r)}},at=(e,t,n)=>{if(e.length===0)return;const[s,r]=Ne(e);s.set(r+t,n),s.delete(r)},Ne=e=>e[e.length-1],mn=(e,t)=>{const n=e._idToShortId.get(t);if(n!=null)return e._storedFields.get(n)},yn=/[\n\r\p{Z}\p{P}]+/u,Me="or",ut="and",wn="and_not",bn=(e,t)=>{e.includes(t)||e.push(t)},lt=(e,t)=>{for(const n of t)e.includes(n)||e.push(n)},ft=({score:e},{score:t})=>t-e,vn=()=>new Map,ne=e=>{const t=new Map;for(const n of Object.keys(e))t.set(parseInt(n,10),e[n]);return t},dt=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[Me]:(e,t)=>{for(const n of t.keys()){const s=e.get(n);if(s==null)e.set(n,t.get(n));else{const{score:r,terms:o,match:i}=t.get(n);s.score=s.score+r,s.match=Object.assign(s.match,i),lt(s.terms,o)}}return e},[ut]:(e,t)=>{const n=new Map;for(const s of t.keys()){const r=e.get(s);if(r==null)continue;const{score:o,terms:i,match:c}=t.get(s);lt(r.terms,i),n.set(s,{score:r.score+o,terms:r.terms,match:Object.assign(r.match,c)})}return n},[wn]:(e,t)=>{for(const n of t.keys())e.delete(n);return e}},En=(e,t,n,s,r,o)=>{const{k:i,b:c,d:a}=o;return Math.log(1+(n-t+.5)/(t+.5))*(a+e*(i+1)/(e+i*(1-c+c*s/r)))},xn=e=>(t,n,s)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,n,s):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,n,s):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,n,s):1}),pt=(e,t,n,s)=>{for(const r of Object.keys(e._fieldIds))if(e._fieldIds[r]===n){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${r}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},On=(e,t,n,s)=>{if(!e._index.has(s)){pt(e,n,t,s);return}const r=e._index.fetch(s,vn),o=r.get(t),i=o?.get(n);!o||typeof i>"u"?pt(e,n,t,s):i<=1?o.size<=1?r.delete(t):o.delete(n):o.set(n,i-1),e._index.get(s).size===0&&e._index.delete(s)},Sn={k:1.2,b:.7,d:.5},In={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(yn),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},gt={combineWith:Me,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Sn},Nn={combineWith:ut,prefix:(e,t,n)=>t===n.length-1},Mn={batchSize:1e3,batchWait:10},_t={minDirtFactor:.1,minDirtCount:20},Rn={...Mn,..._t},mt=Symbol("*"),Tn=(e,t)=>{const n=new Map,s={...e._options.searchOptions,...t};for(const[r,o]of e._documentIds){const i=s.boostDocument?s.boostDocument(o,"",e._storedFields.get(r)):1;n.set(r,{score:i,terms:[],match:{}})}return n},yt=(e,t=Me)=>{if(e.length===0)return new Map;const n=t.toLowerCase();if(!(n in ht))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(ht[n])},Re=(e,t,n,s,r,o,i,c,a,u=new Map)=>{if(o==null)return u;for(const l of Object.keys(i)){const f=i[l],d=e._fieldIds[l],m=o.get(d);if(m==null)continue;let b=m.size;const g=e._avgFieldLength[d];for(const h of m.keys()){if(!e._documentIds.has(h)){On(e,d,h,n),b-=1;continue}const _=c?c(e._documentIds.get(h),n,e._storedFields.get(h)):1;if(!_)continue;const y=m.get(h),R=e._fieldLength.get(h)[d],re=En(y,b,e._documentCount,R,g,a),J=s*r*f*_*re,T=u.get(h);if(T){T.score+=J,bn(T.terms,t);const A=dt(T.match,n);A?A.push(l):T.match[n]=[l]}else u.set(h,{score:J,terms:[t],match:{[n]:[l]}})}}return u},zn=(e,t,n)=>{const s={...e._options.searchOptions,...n},r=(s.fields??e._options.fields).reduce((g,h)=>({...g,[h]:dt(s.boost,h)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:c,bm25:a}=s,{fuzzy:u,prefix:l}={...gt.weights,...i},f=e._index.get(t.term),d=Re(e,t.term,t.term,1,t.termBoost,f,r,o,a);let m,b;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const g=t.fuzzy===!0?.2:t.fuzzy,h=g<1?Math.min(c,Math.round(t.term.length*g)):g;h&&(b=e._index.fuzzyGet(t.term,h))}if(m)for(const[g,h]of m){const _=g.length-t.term.length;if(!_)continue;b?.delete(g);const y=l*g.length/(g.length+.3*_);Re(e,t.term,g,y,t.termBoost,h,r,o,a,d)}if(b)for(const g of b.keys()){const[h,_]=b.get(g);if(!_)continue;const y=u*g.length/(g.length+_);Re(e,t.term,g,y,t.termBoost,h,r,o,a,d)}return d},wt=(e,t,n={})=>{if(t===mt)return Tn(e,n);if(typeof t!="string"){const l={...n,...t,queries:void 0},f=t.queries.map(d=>wt(e,d,l));return yt(f,l.combineWith)}const{tokenize:s,processTerm:r,searchOptions:o}=e._options,i={tokenize:s,processTerm:r,...o,...n},{tokenize:c,processTerm:a}=i,u=c(t).flatMap(l=>a(l)).filter(l=>!!l).map(xn(i)).map(l=>zn(e,l,i));return yt(u,i.combineWith)},bt=(e,t,n={})=>{const{searchOptions:s}=e._options,r={...s,...n},o=wt(e,t,n),i=[];for(const[c,{score:a,terms:u,match:l}]of o){const f=u.length||1,d={id:e._documentIds.get(c),score:a*f,terms:Object.keys(l),queryTerms:u,match:l};Object.assign(d,e._storedFields.get(c)),(r.filter==null||r.filter(d))&&i.push(d)}return t===mt&&r.boostDocument==null||i.sort(ft),i},Cn=(e,t,n={})=>{n={...e._options.autoSuggestOptions,...n};const s=new Map;for(const{score:o,terms:i}of bt(e,t,n)){const c=i.join(" "),a=s.get(c);a!=null?(a.score+=o,a.count+=1):s.set(c,{score:o,terms:i,count:1})}const r=[];for(const[o,{score:i,terms:c,count:a}]of s)r.push({suggestion:o,terms:c,score:i/a});return r.sort(ft),r};class Vn{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const n=t.autoVacuum==null||t.autoVacuum===!0?Rn:t.autoVacuum;this._options={...In,...t,autoVacuum:n,searchOptions:{...gt,...t.searchOptions},autoSuggestOptions:{...Nn,...t.autoSuggestOptions}},this._index=new it,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=_t,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[n,s]of this._index){const r={};for(const[o,i]of s)r[o]=Object.fromEntries(i);t.push([n,r])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let n=0;n<t.length;n++)this._fieldIds[t[n]]=n}}const kn=e=>new Vn(e),$n=({documentCount:e,nextId:t,fieldIds:n,averageFieldLength:s,dirtCount:r,version:o},i)=>{if(o!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=kn(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=n,c._avgFieldLength=s,c._dirtCount=r??0,c._index=new it,c},jn=(e,t)=>{const{index:n,documentIds:s,fieldLength:r,storedFields:o}=e,i=$n(e,t);i._documentIds=ne(s),i._fieldLength=ne(r),i._storedFields=ne(o);for(const[c,a]of i._documentIds)i._idToShortId.set(a,c);for(const[c,a]of n){const u=new Map;for(const l of Object.keys(a))u.set(parseInt(l,10),ne(a[l]));i._index.set(c,u)}return i},Te=(e,t)=>{const n=e.toLowerCase(),s=t.toLowerCase(),r=[];let o=0,i=0;const c=(u,l=!1)=>{let f;i===0?f=u.length>20?`… ${u.slice(-20)}`:u:l?f=u.length+i>100?`${u.slice(0,100-i)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&r.push(f),i+=f.length,l||(r.push(["mark",t]),i+=t.length,i>=100&&r.push(" …"))};let a=n.indexOf(s,o);if(a===-1)return null;for(;a>=0;){const u=a+s.length;if(c(e.slice(o,a)),o=u,i>100)break;a=n.indexOf(s,o)}return i<100&&c(e.slice(o),!0),r},{entries:Dn}=Object,Fn=(e,t)=>t.contents.reduce((n,[,s])=>n+s,0)-e.contents.reduce((n,[,s])=>n+s,0),Pn=(e,t)=>Math.max(...t.contents.map(([,n])=>n))-Math.max(...e.contents.map(([,n])=>n)),vt=(e,t,n={},s="max")=>{const r={};return bt(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...n}).forEach(o=>{const{id:i,terms:c,score:a}=o,u=i.includes("@"),l=i.includes("#"),[f,d]=i.split(/[#@]/),m=Number(f),b=c.sort((h,_)=>h.length-_.length).filter((h,_)=>c.slice(_+1).every(y=>!y.includes(h))),{contents:g}=r[m]??={title:"",contents:[]};if(u)g.push([{type:"customField",id:m,index:d,display:b.map(h=>o.c.map(_=>Te(_,h))).flat().filter(h=>h!==null)},a]);else{const h=b.map(_=>Te(o.h,_)).filter(_=>_!==null);if(h.length&&g.push([{type:l?"heading":"title",id:m,...l&&{anchor:d},display:h},a]),"t"in o&&o.t)for(const _ of o.t){const y=b.map(R=>Te(_,R)).filter(R=>R!==null);y.length&&g.push([{type:"text",id:m,...l&&{anchor:d},display:y},a])}}}),Dn(r).sort(([,o],[,i])=>(s?Fn:Pn)(o,i)).map(([o,{title:i,contents:c}])=>{if(!i){const a=mn(t,o);a&&(i=a.h)}return{title:i,contents:c.map(([a])=>a)}})},Et=(e,t,n={})=>{const s=Cn(t,e,{fuzzy:.2,maxFuzzy:3,...n}).map(({suggestion:r})=>r);return e.includes(" ")?s:s.filter(r=>!r.includes(" "))},An=hn(dn(JSON.parse("{\"/\":{\"documentCount\":120,\"nextId\":120,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2@0\",\"3\":\"3\",\"4\":\"3@0\",\"5\":\"3@1\",\"6\":\"4\",\"7\":\"4@0\",\"8\":\"4@1\",\"9\":\"5\",\"10\":\"5#markdown-介绍\",\"11\":\"5#markdown-配置\",\"12\":\"5#markdown-扩展\",\"13\":\"5#vuepress-扩展\",\"14\":\"5#主题扩展\",\"15\":\"5#选项卡\",\"16\":\"5#脚注\",\"17\":\"5#导入文件\",\"18\":\"5#tex-语法\",\"19\":\"5#任务列表\",\"20\":\"5#图片增强\",\"21\":\"5#上下角标\",\"22\":\"5#组件\",\"23\":\"5@0\",\"24\":\"5@1\",\"25\":\"6\",\"26\":\"6#页面标题\",\"27\":\"6#页面信息\",\"28\":\"6#页面内容\",\"29\":\"6#组件\",\"30\":\"6@0\",\"31\":\"6@1\",\"32\":\"7\",\"33\":\"7@0\",\"34\":\"8\",\"35\":\"8#indexeddb\",\"36\":\"8#使用\",\"37\":\"8#手写防抖和节流\",\"38\":\"8@0\",\"39\":\"9\",\"40\":\"9@0\",\"41\":\"10\",\"42\":\"10#概述\",\"43\":\"10#类型的概念\",\"44\":\"10#动态类型与静态类型\",\"45\":\"10#静态类型的优点\",\"46\":\"10#静态类型的缺点\",\"47\":\"10@0\",\"48\":\"11\",\"49\":\"11#类型声明\",\"50\":\"11#类型推断\",\"51\":\"11#typescript-playground\",\"52\":\"11#ts-node-模块\",\"53\":\"11@0\",\"54\":\"12\",\"55\":\"12#any类型\",\"56\":\"12#基本意义\",\"57\":\"12#unknown-类型\",\"58\":\"12#never-类型\",\"59\":\"12#symbol\",\"60\":\"12#unique-symbol\",\"61\":\"12#类型推断\",\"62\":\"12@0\",\"63\":\"13\",\"64\":\"13#基本类型\",\"65\":\"13#包装对象类型\",\"66\":\"13#包装对象类型与字面量类型\",\"67\":\"13#object-类型与-object-类型\",\"68\":\"13#object-类型\",\"69\":\"13#object-类型-1\",\"70\":\"13#undefined-和-null-的特殊性\",\"71\":\"13#值类型\",\"72\":\"13#联合类型\",\"73\":\"13#交叉类型\",\"74\":\"13#type-命令\",\"75\":\"13#typeof-运算符\",\"76\":\"13#块级类型声明\",\"77\":\"13@0\",\"78\":\"14\",\"79\":\"14#数组\",\"80\":\"14#数组的类型推断\",\"81\":\"14#只读数组-const-断言\",\"82\":\"14#多维数组\",\"83\":\"14#元组\",\"84\":\"14#只读元组\",\"85\":\"14#成员数量的推断\",\"86\":\"14#扩展运算符与成员数量\",\"87\":\"14@0\",\"88\":\"15\",\"89\":\"15#awaited-type\",\"90\":\"15#constructorparameters-type\",\"91\":\"15#exclude-uniontype-excludedmembers\",\"92\":\"15#extract-type-union\",\"93\":\"15#instancetype-type\",\"94\":\"15#nonnullable-type\",\"95\":\"15#omit-type-keys\",\"96\":\"15#omitthisparameter-type\",\"97\":\"15#parameters-type\",\"98\":\"15#partial-type\",\"99\":\"15#pick-type-keys\",\"100\":\"15#readonly-type\",\"101\":\"15#record-keys-type\",\"102\":\"15#required-type\",\"103\":\"15#readonlyarray-type\",\"104\":\"15#returntype-type\",\"105\":\"15#thisparametertype-type\",\"106\":\"15#thistype-type\",\"107\":\"15#字符串类型工具\",\"108\":\"15#uppercase-stringtype\",\"109\":\"15#lowercase-stringtype\",\"110\":\"15#capitalize-stringtype\",\"111\":\"15#uncapitalize-stringtype\",\"112\":\"15@0\",\"113\":\"16\",\"114\":\"16@0\",\"115\":\"17\",\"116\":\"18\",\"117\":\"19\",\"118\":\"20\",\"119\":\"21\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1],\"2\":[null,null,1],\"3\":[1,18],\"4\":[null,null,1],\"5\":[null,null,1],\"6\":[1,20],\"7\":[null,null,1],\"8\":[null,null,1],\"9\":[2,10],\"10\":[2,8],\"11\":[2,12],\"12\":[2,11],\"13\":[2,10],\"14\":[1,8],\"15\":[1,1],\"16\":[1,3],\"17\":[1,1],\"18\":[2,25],\"19\":[1,5],\"20\":[1,2],\"21\":[1,3],\"22\":[1],\"23\":[null,null,1],\"24\":[null,null,1],\"25\":[1,3],\"26\":[1,19],\"27\":[1,20],\"28\":[1,12],\"29\":[1,13],\"30\":[null,null,1],\"31\":[null,null,2],\"32\":[1],\"33\":[null,null,1],\"34\":[1],\"35\":[1,37],\"36\":[1,48],\"37\":[1,27],\"38\":[null,null,1],\"39\":[3],\"40\":[null,null,1],\"41\":[1],\"42\":[1,24],\"43\":[1,65],\"44\":[1,66],\"45\":[1,105],\"46\":[1,44],\"47\":[null,null,1],\"48\":[1],\"49\":[1,33],\"50\":[1,26],\"51\":[2,6],\"52\":[3,70],\"53\":[null,null,1],\"54\":[1],\"55\":[1],\"56\":[1,151],\"57\":[2,118],\"58\":[2,87],\"59\":[1,19],\"60\":[2,107],\"61\":[1,22],\"62\":[null,null,1],\"63\":[1],\"64\":[1,22],\"65\":[1,48],\"66\":[1,52],\"67\":[4,6],\"68\":[2,30],\"69\":[2,36],\"70\":[4,50],\"71\":[1,42],\"72\":[1,41],\"73\":[1,31],\"74\":[2,33],\"75\":[2,62],\"76\":[1,19],\"77\":[null,null,1],\"78\":[1],\"79\":[1,30],\"80\":[1,24],\"81\":[3,46],\"82\":[1,16],\"83\":[1,66],\"84\":[1,13],\"85\":[1,14],\"86\":[1,39],\"87\":[null,null,1],\"88\":[1],\"89\":[1,26],\"90\":[1,48],\"91\":[1,52],\"92\":[1,44],\"93\":[1,63],\"94\":[1,37],\"95\":[1,36],\"96\":[1,32],\"97\":[1,69],\"98\":[1,17],\"99\":[1,36],\"100\":[1,45],\"101\":[1,38],\"102\":[1,32],\"103\":[1,30],\"104\":[1,53],\"105\":[1,26],\"106\":[1,55],\"107\":[1,12],\"108\":[1,9],\"109\":[1,9],\"110\":[1,9],\"111\":[1,10],\"112\":[null,null,1],\"113\":[1],\"114\":[null,null,1],\"115\":[1,3],\"116\":[2],\"117\":[1],\"118\":[2],\"119\":[1]},\"averageFieldLength\":[1.2623290075075737,27.911700834435347,0.7766711286990648],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"将你的个人介绍和档案放置在此处。\"]},\"1\":{\"h\":\"主要功能与配置演示\"},\"2\":{\"c\":[\"使用指南\"]},\"3\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"4\":{\"c\":[\"使用指南\"]},\"5\":{\"c\":[\"禁用\"]},\"6\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"7\":{\"c\":[\"指南\"]},\"8\":{\"c\":[\"布局\"]},\"9\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"10\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"11\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"12\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"13\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"14\":{\"h\":\"主题扩展\",\"t\":[\"通过 VuePress 插件，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"15\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"16\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"17\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"18\":{\"h\":\"TeX 语法\",\"t\":[\"$$ \\\\frac {\\\\partial^r} {\\\\partial \\\\omega^r} \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) = \\\\left(\\\\frac {y^{\\\\omega}} {\\\\omega}\\\\right) \\\\left{(\\\\log y)^r + \\\\sum_{i=1}^r \\\\frac {(-1)^i r \\\\cdots (r-i+1) (\\\\log y)^{r-i}} {\\\\omega^i} \\\\right} $$\",\"查看详情\"]},\"19\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"20\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"组件\"},\"23\":{\"c\":[\"使用指南\"]},\"24\":{\"c\":[\"Markdown\"]},\"25\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"26\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"27\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"28\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"29\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"30\":{\"c\":[\"使用指南\"]},\"31\":{\"c\":[\"页面配置\",\"使用指南\"]},\"32\":{\"h\":\"个人学习文档\"},\"33\":{\"c\":[\"学习文档\"]},\"34\":{\"h\":\"前端存储\"},\"35\":{\"h\":\"indexedDB\",\"t\":[\"对于本地话存储 我们一般都会想到cookie webStorage（sessionStorage、localStorage）对于这些存储方式，存在以下比较明显的缺点\",\"存储量小 web storage 的存储量最大也只有5M。\",\"存取不方便 存入的内容会经过序列化 取值的时候需要经过反序列化。\",\"indexedDB 是一种底层的API，用于在客户端存储大量的结构化数据（包括文件和二进制对象）\",\"indexedDB 是一个基于JavaScript的面向对象数据库，允许你存储和检索用键索引的对象可以存储结构化克隆算法支持的任何对象[Array ArrayBuffer Boolean DataView Date Error Map Object RegExp Set String TypedArray] Error 仅支持部分\",\"存取方便 不需要序列化\",\"异步存取\",\"庞大的存储量\"]},\"36\":{\"h\":\"使用\",\"t\":[\"localforage.getItem('somekey').then(function (value) { // 当离线仓库中的值被载入时，此处代码运行 console.log(value); }).catch(function (err) { // 当出错时，此处代码运行 console.log(err); }); // 不同于 localStorage，你可以存储非字符串类型 localforage.setItem('my array', [1, 2, 'three']).then(function (value) { // 如下输出 `1` console.log(value[0]); }).catch(function (err) { // 当出错时，此处代码运行 console.log(err); }); localforage.removeItem('somekey').then(function () { // 当值被移除后，此处代码运行 console.log('Key is cleared!'); }).catch(function (err) { // 当出错时，此处代码运行 console.log(err); }); localforage.clear().then(function () { // 当数据库被全部删除后，此处代码运行 console.log('Database is now empty.'); }).catch(function (err) { // 当出错时，此处代码运行 console.log(err); }); var store = localforage.createInstance({ name: \\\"nameHere\\\" }); var otherStore = localforage.createInstance({ name: \\\"otherName\\\" }); // 设置某个数据仓库 key 的值不会影响到另一个数据仓库 store.setItem(\\\"key\\\", \\\"value\\\"); otherStore.setItem(\\\"key\\\", \\\"value2\\\");\"]},\"37\":{\"h\":\"手写防抖和节流\",\"t\":[\"// 节流 function throttle(func, delay) { let lastExecTime = 0; let timeoutId; return function (...args) { const currentTime = Date.now(); if (currentTime - lastExecTime < delay) { clearTimeout(timeoutId); timeoutId = setTimeout(() => { lastExecTime = currentTime; func.apply(this, args); }, delay); } else { lastExecTime = currentTime; func.apply(this, args); } }; } // 防抖 function debounce(func, delay) { let timeoutId; return function (...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => { func.apply(this, args); }, delay); }; }\"]},\"38\":{\"c\":[\"JavaScript\"]},\"39\":{\"h\":\"Vue3 相当于Vue2 的提升\"},\"40\":{\"c\":[\"Vue3\"]},\"41\":{\"h\":\"TS简介\"},\"42\":{\"h\":\"概述\",\"t\":[\"TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。 它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。 TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。 TypeScript 对 JavaScript 添加的最主要部分，就是一个独立的类型系统。\"]},\"43\":{\"h\":\"类型的概念\",\"t\":[\"类型（type）指的是一组具有相同特征的值。如果两个值具有某种共同的特征，就可以说，它们属于同一种类型。 举例来说，123和456这两个值，共同特征是都能进行数值运算，所以都属于“数值”（number）这个类型。 一旦确定某个值的类型，就意味着，这个值具有该类型的所有特征，可以进行该类型的所有运算。凡是适用该类型的地方，都可以使用这个值；凡是不适用该类型的地方，使用这个值都会报错。 可以这样理解，类型是人为添加的一种编程约束和用法提示。 主要目的是在软件开发过程中，为编译器和开发工具提供更多的验证和帮助，帮助提高代码质量，减少错误。 下面是一段简单的 TypeScript 代码，演示一下类型系统的作用。\",\"function addOne(n: number) { return n + 1; }\",\"上面示例中，函数addOne()有一个参数n，类型为数值（number），表示这个位置只能使用数值，传入其他类型的值就会报错。\",\"addOne('hello') // 报错\",\"上面示例中，函数addOne()传入了一个字符串hello，TypeScript 发现类型不对，就报错了，指出这个位置只能传入数值，不能传入字符串。 JavaScript 语言就没有这个功能，不会检查类型对不对。开发阶段很可能发现不了这个问题，代码也许就会原样发布，导致用户在使用时遇到错误。 作为比较，TypeScript 是在开发阶段报错，这样有利于提早发现错误，避免使用时报错。另一方面，函数定义里面加入类型，具有提示作用，可以告诉开发者这个函数怎么用。\"]},\"44\":{\"h\":\"动态类型与静态类型\",\"t\":[\"前面说了，TypeScript 的主要功能是为 JavaScript 添加类型系统。大家可能知道，JavaScript 语言本身就有一套自己的类型系统，比如数值123和字符串Hello。 但是，JavaScript 的类型系统非常弱，而且没有使用限制，运算符可以接受各种类型的值。在语法上，JavaScript 属于动态类型语言。 请看下面的 JavaScript 代码。\",\"// 例一let x = 1; x = 'hello'; // 例二let y = { foo: 1 }; delete y.foo; y.bar = 2;\",\"上面的例一，变量x声明时，值的类型是数值，但是后面可以改成字符串。所以，无法提前知道变量的类型是什么，也就是说，变量的类型是动态的。 上面的例二，变量y是一个对象，有一个属性foo，但是这个属性是可以删掉的，并且还可以新增其他属性。所以，对象有什么属性，这个属性还在不在，也是动态的，没法提前知道。 正是因为存在这些动态变化，所以 JavaScript 的类型系统是动态的，不具有很强的约束性。这对于提前发现代码错误，非常不利。 TypeScript 引入了一个更强大、更严格的类型系统，属于静态类型语言。 上面的代码在 TypeScript 里面都会报错。\",\"// 例一let x = 1; x = 'hello'; // 报错// 例二let y = { foo: 1 }; delete y.foo; // 报错 y.bar = 2; // 报错\",\"上面示例中，例一的报错是因为变量赋值时，TypeScript 已经推断确定了类型，后面就不允许再赋值为其他类型的值，即变量的类型是静态的。例二的报错是因为对象的属性也是静态的，不允许随意增删。 TypeScript 的作用，就是为 JavaScript 引入这种静态类型特征。\"]},\"45\":{\"h\":\"静态类型的优点\",\"t\":[\"静态类型有很多好处，这也是 TypeScript 想要达到的目的。\",\"有利于代码的静态分析。 有了静态类型，不必运行代码，就可以确定变量的类型，从而推断代码有没有错误。这就叫做代码的静态分析。 这对于大型项目非常重要，单单在开发阶段运行静态检查，就可以发现很多问题，避免交付有问题的代码，大大降低了线上风险。\",\"有利于发现错误。 由于每个值、每个变量、每个运算符都有严格的类型约束，TypeScript 就能轻松发现拼写错误、语义错误和方法调用错误，节省程序员的时间。\",\"let obj = {message: ''}; console.log(obj.messege); // 报错\",\"上面示例中，不小心把message拼错了，写成messege。TypeScript 就会报错，指出没有定义过这个属性。JavaScript 遇到这种情况是不报错的。\",\"const a = 0; const b = true; const result = a + b; // 报错\",\"上面示例是合法的 JavaScript 代码，但是没有意义，不应该将数值a与布尔值b相加。TypeScript 就会直接报错，提示运算符+不能用于数值和布尔值的相加。\",\"function hello() { return 'hello world'; } hello().find('hello'); // 报错\",\"上面示例中，hello()返回的是一个字符串，TypeScript 发现字符串没有find()方法，所以报错了。如果是 JavaScript，只有到运行阶段才会报错。\",\"更好的 IDE 支持，做到语法提示和自动补全。 IDE（集成开发环境，比如 VSCode）一般都会利用类型信息，提供语法提示功能（编辑器自动提示函数用法、参数等）和自动补全功能（只键入一部分的变量名或函数名，编辑器补全后面的部分）。\",\"提供了代码文档。 类型信息可以部分替代代码文档，解释应该如何使用这些代码，熟练的开发者往往只看类型，就能大致推断代码的作用。借助类型信息，很多工具能够直接生成文档。\",\"有助于代码重构。 修改他人的 JavaScript 代码，往往非常痛苦，项目越大越痛苦，因为不确定修改后是否会影响到其他部分的代码。 类型信息大大减轻了重构的成本。一般来说，只要函数或对象的参数和返回值保持类型不变，就能基本确定，重构后的代码也能正常运行。如果还有配套的单元测试，就完全可以放心重构。越是大型的、多人合作的项目，类型信息能够提供的帮助越大。 综上所述，TypeScript 有助于提高代码质量，保证代码安全，更适合用在大型的企业级项目。这就是为什么大量 JavaScript 项目转成 TypeScript 的原因。\"]},\"46\":{\"h\":\"静态类型的缺点\",\"t\":[\"静态类型也存在一些缺点。\",\"丧失了动态类型的代码灵活性。 动态类型有非常高的灵活性，给予程序员很大的自由，静态类型将这些灵活性都剥夺了。\",\"增加了编程工作量。 有了类型之后，程序员不仅需要编写功能，还需要编写类型声明，确保类型正确。这增加了不少工作量，有时会显著拖长项目的开发时间。\",\"更高的学习成本。 类型系统通常比较复杂，要学习的东西更多，要求开发者付出更高的学习成本。\",\"引入了独立的编译步骤。 原生的 JavaScript 代码，可以直接在 JavaScript 引擎运行。添加类型系统以后，就多出了一个单独的编译步骤，检查类型是否正确，并将 TypeScript 代码转成 JavaScript 代码，这样才能运行。\",\"兼容性问题。 TypeScript 依赖 JavaScript 生态，需要用到很多外部模块。但是，过去大部分 JavaScript 项目都没有做 TypeScript 适配，虽然可以自己动手做适配，不过使用时难免还是会有一些兼容性问题。 总的来说，这些缺点使得 TypeScript 不一定适合那些小型的、短期的个人项目。\"]},\"47\":{\"c\":[\"TypeScript\"]},\"48\":{\"h\":\"基本用法\"},\"49\":{\"h\":\"类型声明\",\"t\":[\"TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明\",\"let foo: string;\",\"上面示例中，变量foo的后面使用冒号，声明了它的类型为string。 类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。\",\"function toString(num: number): string { return String(num); }\",\"上面示例中，函数toString()的参数num的类型是number。参数列表的圆括号后面，声明了返回值的类型是string。 注意，变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。\"]},\"50\":{\"h\":\"类型推断\",\"t\":[\"类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。\",\"let foo = 123;\",\"上面示例中，变量foo并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为number。 后面，如果变量foo更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错\",\"TypeScript 也可以推断函数的返回值。\",\"function toString(num: number) { return String(num); }\"]},\"51\":{\"h\":\"TypeScript Playground\",\"t\":[\"最简单的 TypeScript 使用方法，就是使用官网的在线编译页面，叫做\",\"TypeScript Playground\"]},\"52\":{\"h\":\"Ts-node 模块\",\"t\":[\"ts-node 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。 使用时，可以先全局安装它。\",\"$ npm install -g ts-node\",\"安装后，就可以直接运行 TypeScript 脚本。\",\"$ ts-node script.ts\",\"上面命令运行了 TypeScript 脚本script.ts，给出运行结果。 如果不安装 ts-node，也可以通过 npx 调用它来运行 TypeScript 脚本。\",\"$ npx ts-node script.ts\",\"上面命令中，npx会在线调用 ts-node，从而在不安装的情况下，运行script.ts。 如果执行 ts-node 命令不带有任何参数，它会提供一个 TypeScript 的命令行 REPL 运行环境，你可以在这个环境中输入 TypeScript 代码，逐行执行。\",\"$ ts-node\",\"上面示例中，单独运行ts-node命令，会给出一个大于号，这就是 TypeScript 的 REPL 运行环境，可以逐行输入代码运行。\",\"$ ts-node const twice = (x:string) => x + x; twice('abc') 'abcabc' >\",\"上面示例中，在 TypeScript 命令行 REPL 环境中，先输入一个函数twice，然后调用该函数，就会得到结果。 要退出这个 REPL 环境，可以按下 Ctrl + d，或者输入.exit。 如果只是想简单运行 TypeScript 代码看看结果，ts-node 不失为一个便捷的方法。\"]},\"53\":{\"c\":[\"TypeScript\"]},\"54\":{\"h\":\"特殊类型\"},\"55\":{\"h\":\"any类型\"},\"56\":{\"h\":\"基本意义\",\"t\":[\"any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。\",\"let x: any; x = 1; // 正确 x = 'foo'; // 正确 x = true; // 正确\",\"上面示例中，变量x的类型是any，就可以被赋值为任意类型的值。 变量类型一旦设为any ，TypeScript实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。\",\"let x: any = 'hello'; x(1) // 不报错 x.foo = 100; // 不报错\",\"上面示例中，变量x的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。 原因就是x的类型是any，TypeScript 不对其进行类型检查。由于这个原因，应该尽量避免使用any类型，否则就失去了使用 TypeScript 的意义。 实际开发中，any类型主要适用以下两个场合。\",\"出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为any。\",\"为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为any。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上any，TypeScript 编译时就不会报错。 总之，TypeScript 认为，只要开发者使用了any类型，就表示开发者想要自己来处理这些代码，所以就不对any类型进行任何限制，怎么使用都可以。 从集合论的角度看，any类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。\",\"类型推断问题 对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是any。\",\"function add(x, y) { return x + y; } add(1, [1, 2, 3]) // 不报错\",\"上面示例中，函数add()的参数变量x和y，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是any。以至于后面就不再对函数add()进行类型检查了，怎么用都可以。 这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为any。 TypeScript 提供了一个编译选项noImplicitAny，打开该选项，只要推断出any类型就会报错。\",\"$ tsc --noImplicitAny app.ts\",\"上面命令使用了noImplicitAny编译选项进行编译，这时上面的函数add()就会报错。 这里有一个特殊情况，即使打开了noImplicitAny，使用let和var命令声明变量，但不赋值也不指定类型，是不会报错的。\",\"var x; // 不报错 let y; // 不报错\",\"上面示例中，变量x和y声明时没有赋值，也没有指定类型，TypeScript 会推断它们的类型为any。这时即使打开了noImplicitAny，也不会报错。\",\"let x; x = 123; x = {foo: 'hello'};\",\"上面示例中，变量x的类型推断为any，但是不报错，可以顺利通过编译。 由于这个原因，建议使用let和var声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。 const命令没有这个问题，因为 JavaScript 语言规定const声明变量时，必须同时进行初始化（赋值）。const x; // 报错 上面示例中，const命令声明的x是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为any的问题。\",\"污染问题 any类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。\",\"let x:any = 'hello'; let y:number; y = x; // 不报错 y * 123 // 不报错 y.toFixed() // 不报错上面示例中，变量x的类型是any，实际的值是一个字符串。变量y的类型是number，表示这是一个数值变量，但是它被赋值为x，这时并不会报错。然后，变量y继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。 污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用any类型的另一个主要原因。\"]},\"57\":{\"h\":\"Unknown 类型\",\"t\":[\"为了解决any类型“污染”其他变量的问题，TypeScript 3.0 引入了unknown类型。它与any含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像any那样自由，可以视为严格版的any。 unknown跟any的相似之处，在于所有类型的值都可以分配给unknown类型。\",\"let x: unknown; x = true; // 正确 x = 42; // 正确 x = 'Hello World'; // 正确\",\"上面示例中，变量x的类型是unknown，可以赋值为各种类型的值。这与any的行为一致。 unknown类型跟any类型的不同之处在于，它不能直接使用。主要有以下几个限制。 首先，unknown类型的变量，不能直接赋值给其他类型的变量（除了any类型和unknown类型）。\",\"let v: unknown = 123; let v1: boolean = v; // 报错let v2:number = v; // 报错\",\"上面示例中，变量v是unknown类型，赋值给any和unknown以外类型的变量都会报错，这就避免了污染问题，从而克服了any类型的一大缺点。 其次，不能直接调用unknown类型变量的方法和属性。\",\"let v1: unknown = {foo: 123}; v1.foo // 报错let v2:unknown = 'hello'; v2.trim() // 报错let v3:unknown = (n = 0) => n + 1; v3() // 报错\",\"上面示例中，直接调用unknown类型变量的属性和方法，或者直接当作函数执行，都会报错。 再次，unknown类型变量能够进行的运算是有限的，只能进行比较运算（运算符==、=、!=、!、||、&&、?）、取反运算（运算符!）、typeof运算符和instanceof运算符这几种，其他运算都会报错。\",\"let a: unknown = 1; a + 1 // 报错 a === 1 // 正确\",\"上面示例中，unknown类型的变量a进行加法运算会报错，因为这是不允许的运算。但是，进行比较运算就是可以的。 那么，怎么才能使用unknown类型变量呢？ 答案是只有经过“类型缩小”，unknown类型变量才可以使用。所谓“类型缩小”，就是缩小unknown变量的类型范围，确保不会出错。\",\"let a: unknown = 1; if (typeof a === 'number') { let r = a + 10; // 正确 }\",\"上面示例中，unknown类型的变量a经过typeof运算以后，能够确定实际类型是number，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。 下面是另一个例子。\",\"let s: unknown = 'hello'; if (typeof s === 'string') { s.length; // 正确 }\",\"上面示例中，确定变量s的类型为字符串以后，才能调用它的length属性。 这样设计的目的是，只有明确unknown变量的实际类型，才允许使用它，防止像any那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。 总之，unknown可以看作是更安全的any。一般来说，凡是需要设为any类型的地方，通常都应该优先考虑设为unknown类型。 在集合论上，unknown也可以视为所有其他类型（除了any）的全集，所以它和any一样，也属于 TypeScript 的顶层类型。\"]},\"58\":{\"h\":\"Never 类型\",\"t\":[\"为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。 由于不存在任何属于“空类型”的值，所以该类型被称为never，即不可能有这样的值。\",\"let x: never;\",\"上面示例中，变量x的类型是never，就不可能赋给它任何值，否则都会报错。 never类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性，详见后面章节。另外，不可能返回值的函数，返回值的类型就可以写成never，详见《函数》一章。 如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于never类型。\",\"function fn(x: string | number) { if (typeof x === 'string') { // ... } else if (typeof x === 'number') { // ... } else { x; // never 类型 } }\",\"上面示例中，参数变量x可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个else分支里面，x就是never类型了。 never类型的一个重要特点是，可以赋值给任意其他类型。\",\"function f(): never { throw new Error('Error'); } let v1: number = f(); // 不报错 let v2: string = f(); // 不报错 let v3: boolean = f(); // 不报错\",\"上面示例中，函数f()会抛出错误，所以返回值类型可以写成never，即不可能返回任何值。各种其他类型的变量都可以赋值为f()的运行结果（never类型）。 为什么never类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了never类型。因此，never类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。 总之，TypeScript 有两个“顶层类型”（any和unknown），但是“底层类型”只有never唯一一个。\"]},\"59\":{\"h\":\"symbol\",\"t\":[\"Symbol 是ES2015 新引入的一种原始类型的值。它类似字符串，但是每一个Symbol值都是独一无二的， 与其他任何值都不相等。 Symbol 值通过Symbol()函数生成。在 TypeScript 里面，Symbol 的类型使用symbol表示。\",\"let x: symbol = Symbol(); let y: symbol = Symbol(); x === y // false\"]},\"60\":{\"h\":\"unique symbol\",\"t\":[\"symbol类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。 比如，5是一个具体的数值，就用5这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不ss出只包含单个 Symbol 值的那种值类型。 为了解决这个问题，TypeScript 设计了symbol的一个子类型unique symbol，它表示单个的、某个具体的 Symbol 值。 因为unique symbol表示单个值，所以这个类型的变量是不能修改值的，只能用const命令声明，不能用let声明。\",\"// 正确 const x: unique symbol = Symbol(); // 报错 // let y:unique symbol = Symbol();\",\"const命令为变量赋值 Symbol 值时，变量类型默认就是unique symbol，所以类型可以省略不写。\",\"const x: unique symbol = Symbol(); // 等同于const x = Symbol();\",\"每个声明为unique symbol类型的变量，它们的值都是不一样的，其实属于两个值类型。\",\"const a: unique symbol = Symbol(); const b: unique symbol = Symbol(); a === b // 报错\",\"上面示例中，变量a和变量b的类型虽然都是unique symbol，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。 由于 Symbol 类似于字符串，可以参考下面的例子来理解。\",\"const a: 'hello' = 'hello'; const b: 'world' = 'world'; a === b // 报错\",\"上面示例中，变量a和b都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。 而且，由于变量a和b是两个类型，就不能把一个赋值给另一个。\",\"const a: unique symbol = Symbol(); const b: unique symbol = a; // 报错\",\"例变量b的类型，如果要写成与变量a同一个unique symbol值类型，只能写成类型为typeof a。\",\"const a: unique symbol = Symbol(); const b: typeof a = a; // 正确\",\"不过我们知道，相同参数的Symbol.for()方法会返回相同的 Symbol 值。TypeScript 目前无法识别这种情况，所以可能出现多个 unique symbol 类型的变量，等于同一个 Symbol 值的情况。\",\"const a: unique symbol = Symbol.for('foo'); const b: unique symbol = Symbol.for('foo');\",\"unique symbol 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。\",\"const a: unique symbol = Symbol(); const b: symbol = a; // 正确 // const c:unique symbol = b; // 报错\",\"unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。\",\"const x: unique symbol = Symbol(); const y: symbol = Symbol(); interface Foo { [x]: string; // 正确 [y]: string; // 报错 }\",\"上面示例中，变量y当作属性名，但是y的类型是 symbol，不是固定不变的值，导致报错。 unique symbol类型也可以用作类（class）的属性值，但只能赋值给类的readonly static属性。\",\"class C { static readonly foo: unique symbol = Symbol(); }\",\"上面示例中，静态只读属性foo的类型就是unique symbol。注意，这时static和readonly两个限定符缺一不可，这是为了保证这个属性是固定不变的。\"]},\"61\":{\"h\":\"类型推断\",\"t\":[\"如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。 let命令声明的变量，推断类型为 symbol。\",\"// 类型为 symbol let x = Symbol();\",\"const命令声明的变量，推断类型为 unique symbol。\",\"// 类型为 unique symbol const x = Symbol();\",\"但是，const命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。\",\"let x = Symbol(); // 类型为 symbol const y = x;\",\"let命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。\",\"const x = Symbol(); // 类型为 symbol let y = x;\"]},\"62\":{\"c\":[\"TypeScript\"]},\"63\":{\"h\":\"类型大全\"},\"64\":{\"h\":\"基本类型\",\"t\":[\"JavaScript 语言（注意，不是 typescript :no-line-numbers）将值分成8种类型。\",\"boolean\",\"string\",\"number\",\"bigint\",\"symbol\",\"object\",\"undefined\",\"null\",\"typescript :no-line-numbers 继承了 JavaScript 的类型设计，以上8种类型可以看作 typescript :no-line-numbers 的基本类型。\"]},\"65\":{\"h\":\"包装对象类型\",\"t\":[\"JavaScript 的8种类型之中，undefined和null其实是两个特殊值，object属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。\",\"boolean\",\"string\",\"number\",\"bigint\",\"symbol\",\"上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。\",\"'hello'.charAt(1) // 'e'\",\"字符串hello执行了charAt()方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，charAt()方法其实是定义在包装对象上。 五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即Symbol()和BigInt()不能作为构造函数使用），但是剩下三种可以。\",\"Boolean()\",\"String()\",\"Number()\"]},\"66\":{\"h\":\"包装对象类型与字面量类型\",\"t\":[\"由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。\",\"'hello' // 字面量new String('hello') // 包装对象\",\"上面示例中，第一行是字面量，第二行是包装对象，它们都是字符串。 为了区分这两种情况，typescript :no-line-numbers 对五种原始类型分别提供了大写和小写两种类型。\",\"Boolean 和 boolean\",\"String 和 string\",\"Number 和 number\",\"BigInt 和 bigint\",\"Symbol 和 symbol\",\"const s1: String = 'hello'; // 正确 const s2: String = new String('hello'); // 正确 const s3: string = 'hello'; // 正确 const s4: string = new String('hello'); // 报错\",\"Symbol()和BigInt()这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此Symbol和BigInt这两个类型虽然存在，但是完全没有使用的理由。\",\"提示\",\"没有使用意义\",\"let a = Object(Symbol()); let b = Object(BigInt());\"]},\"67\":{\"h\":\"Object 类型与 object 类型\",\"t\":[\"typescript :no-line-numbers 的对象类型也有大写Object和小写object两种。\"]},\"68\":{\"h\":\"Object 类型\",\"t\":[\"大写的Object类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是Object类型，这囊括了几乎所有的值。\",\"let obj: Object; obj = true; obj = 'hi'; obj = 1; obj = {foo: 123}; obj = [1, 2]; obj = (a: number) => a + 1;\",\"事实上，除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型。\",\"let obj: Object; obj = undefined; // 报错 obj = null; // 报错\",\"空对象{}是Object类型的简写形式，所以使用Object时常常用空对象代替。\"]},\"69\":{\"h\":\"object 类型\",\"t\":[\"小写的object类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。\",\"let obj: object; obj = {foo: 123}; obj = [1, 2]; obj = (a: number) => a + 1; obj = true; // 报错 obj = 'hi'; // 报错 obj = 1; // 报错\",\"注意\",\"大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型object，不使用大写类型Object。 无论是大写的Object类型，还是小写的object类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。\"]},\"70\":{\"h\":\"undefined 和 null 的特殊性\",\"t\":[\"undefined和null既是值，又是类型。\",\"let age: number = 24; age = null; // 正确 age = undefined; // 正确\",\"JavaScript 的行为是，变量如果等于undefined就表示还没有赋值，如果等于null就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。 但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。\",\"const obj: object = undefined; obj.toString() // 编译不报错，运行就报错\",\"提示\",\"为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项strictNullChecks。只要打开这个选项，undefined和null就不能赋值给其他类型的变量（除了any类型和unknown类型）。\",\"// tsc --strictNullChecks app.ts let age: number = 24; age = null; // 报错 age = undefined; // 报错\",\"tsconfig.json\",\"{ \\\"compilerOptions\\\": { \\\"strictNullChecks\\\": true } }\",\"// 打开 strictNullChecks let x: undefined = null; // 报错 let y: null = undefined; // 报错\",\"总之，打开strictNullChecks以后，undefined和null只能赋值给自身，或者any类型和unknown类型的变量。\"]},\"71\":{\"h\":\"值类型\",\"t\":[\"TypeScript 规定，单个值也是一种类型，称为“值类型”。\",\"let x: 'hello'; x = 'hello'; // 正确 x = 'world'; // 报错\",\"TypeScript 推断类型时，遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。\",\"// x 的类型是 \\\"https\\\" const x = 'https'; // y 的类型是 string const y: string = 'https'; // x1 的类型是 { foo: number } const x1 = {foo: 1};\",\"提示\",\"值类型可能会出现一些很奇怪的报错。\",\"const x: 5 = 4 + 1; // 报错\",\"上面示例中，等号左侧的类型是数值5，等号右侧4 + 1的类型，TypeScript 推测为number。由于5是number的子类型，number是5的父类型，父类型不能赋值给子类型，所以报错了。 但是，反过来是可以的，子类型可以赋值给父类型。\",\" let x: 5 = 5; let y: number = 4 + 1; x = y; // 报错 y = x; // 正确\"]},\"72\":{\"h\":\"联合类型\",\"t\":[\"联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。 联合类型A|B表示，任何一个类型只要属于A或B，就属于联合类型A|B。\",\"let x: string | number; x = 123; // 正确 x = 'abc'; // 正确 let setting: true | false; let gender: 'male' | 'female'; let rainbowColor: '赤' | '橙' | '黄' | '绿' | '青' | '蓝' | '紫';\",\"提示\",\"打开编译选项strictNullChecks后，其他类型的变量不能赋值为undefined或null。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。\",\"let name: string | null; name = 'John'; name = null;\"]},\"73\":{\"h\":\"交叉类型\",\"t\":[\"交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号&表示。 交叉类型A&B表示，任何一个类型必须同时属于A和B，才属于交叉类型A&B，即交叉类型同时满足A和B的特征。\",\"let x: number & string;\",\"上面示例中，变量x同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为x的类型实际是never。\",\"let obj: { foo: string } & { bar: string }; obj = { foo: 'hello', bar: 'world' };\",\"type A = { foo: number }; type B = A & { bar: number };\"]},\"74\":{\"h\":\"type 命令\",\"t\":[\"type Age = number; let age: Age = 55;\",\"别名不允许重名。\",\"type Color = 'red'; type Color = 'blue'; // 报错\",\"别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。\",\"type Color = 'red'; if (Math.random() < 0.5) { type Color = 'blue'; }\",\"别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。\",\"type World = \\\"world\\\"; type Greeting = `hello ${World}`;\"]},\"75\":{\"h\":\"typeof 运算符\",\"t\":[\"typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。 JavaScript 里面，typeof运算符只可能返回八种结果，而且都是字符串。\",\"typeof undefined; // \\\"undefined\\\" typeof true; // \\\"boolean\\\" typeof 1337; // \\\"number\\\" typeof \\\"foo\\\"; // \\\"string\\\" typeof {}; // \\\"object\\\" typeof parseInt; // \\\"function\\\" typeof Symbol(); // \\\"symbol\\\" typeof 127n // \\\"bigint\\\"\",\"TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。\",\"const a = {x: 0}; type T0 = typeof a; // { x: number } type T1 = typeof a.x; // number\",\"提示\",\"这种用法的typeof返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。 也就是说，同一段代码可能存在两种typeof运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。\",\"let a = 1; let b: typeof a; if (typeof a === 'number') { b = a; }\",\"type T = typeof Date (); // 报错\",\"上面示例会报错，原因是 typeof 的参数不能是一个值的运算式，而Date()需要运算才知道结果。 typeof命令的参数不能是类型。\",\"type Age = number; type MyAge = typeof Age; // 报错\"]},\"76\":{\"h\":\"块级类型声明\",\"t\":[\"TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。\",\"if (true) { type T = number; let v: T = 5; } else { type T = string; let v: T = 'hello'; }\"]},\"77\":{\"c\":[\"TypeScript\"]},\"78\":{\"h\":\"数组与元组\"},\"79\":{\"h\":\"数组\",\"t\":[\"TypeScript数组有一个根本特征： 所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。\",\"let arr: number[] = [1, 2, 3]; let arr1: Array<number> = [1, 2, 3];\",\"如果数组成员的类型比较复杂，可以写在圆括号里面。\",\"let arr: (number | string)[]; let arr1: Array<number | string>;\",\"这个例子里面的圆括号是必须的，否则因为竖杠|的优先级低于[]，\",\"TypeScript 允许使用方括号读取数组成员的类型。\",\"type Names = string[]; type Name = Names[0]; // string\",\"由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样。\",\"type Names = string[]; type Name = Names[number]; // string\"]},\"80\":{\"h\":\"数组的类型推断\",\"t\":[\"如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。 如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是any[]。\",\"const arr = []; arr // 推断为 any[] arr.push(123); arr // 推断类型为 number[] arr.push('abc'); arr // 推断类型为 (string|number)[]\",\"类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。\",\"// 推断类型为 number[] const arr = [123]; arr.push('abc'); // 报错\"]},\"81\":{\"h\":\"只读数组，const 断言\",\"t\":[\"上面示例中，修改const命令声明的数组的成员是允许的。 但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。 TypeScript 允许声明只读数组，方法是在数组类型前面加上readonly关键字。\",\"提示\",\"只读数组没有pop()、push()之类会改变原数组的方法\",\"const arr: readonly number[] = [0, 1]; arr[1] = 2; // 报错 arr.push(3); // 报错delete arr[0]; // 报错\",\"子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型number[]可以用于所有使用父类型的场合，反过来就不行。\",\"let a1: number[] = [0, 1]; let a2: readonly number[] = a1; // 正确 a1 = a2; // 报错\",\"子类型number[]可以赋值给父类型readonly number[]，但是反过来就会报错。\",\"function getSum(s: number[]) {// ... } const arr: readonly number[] = [1, 2, 3]; getSum(arr) // 报错 相当于 只读数组赋值给可变数组 所以报错\",\"只读写法\",\"const a1: ReadonlyArray<number> = [0, 1]; const a2: Readonly<number[]> = [0, 1]; const arr = [0, 1] as const; arr[0] = [2]; // 报错\"]},\"82\":{\"h\":\"多维数组\",\"t\":[\"TypeScript 使用T[][]的形式，表示二维数组，T是最底层数组成员的类型。\",\" var multi: number[][] = [[1, 2, 3], [23, 24, 25]];\"]},\"83\":{\"h\":\"元组\",\"t\":[\"元组（tuple）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。\",\"const s: [string, string, boolean] = ['a', 'b', true];\",\"元组成员的类型可以添加问号后缀（?），表示该成员是可选的。\",\"let a: [number, number?] = [1];\",\"提示\",\"问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。\",\"由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。\",\" let x: [string, string] = ['a', 'b']; x[2] = 'c'; // 报错\",\"相关信息\",\"使用扩展运算符（...），可以表示不限成员数量的元组\",\"type NamedNums = [string, ...number[] ]; const a: NamedNums = ['A', 1, 2]; const b: NamedNums = ['B', 1, 2, 3];\",\"扩展运算符（...）用在元组的任意位置都可以，它的后面只能是一个数组或元组。\",\"type t1 = [string, number, ...boolean[]]; type t2 = [string, ...boolean[], number]; type t3 = [...boolean[], string, number];\",\"如果不确定元组成员的类型和数量，可以写成下面这样。\",\"type Tuple = [...any[]];\",\"元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。\",\"type Color = [red: number, green: number, blue: number]; const c: Color = [255, 255, 255];\",\"元组可以通过方括号，读取成员类型。\",\"type Tuple = [string, number]; type Age = Tuple[1]; // number\"]},\"84\":{\"h\":\"只读元组\",\"t\":[\"元组也可以是只读的，不允许修改，有两种写法。\",\"// 写法一 type t = readonly [number, string] // 写法二 type t = Readonly<[number, string]>\"]},\"85\":{\"h\":\"成员数量的推断\",\"t\":[\"如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。\",\"function f(point: [number, number]) { if (point.length === 3) { // 报错// ... } }\"]},\"86\":{\"h\":\"扩展运算符与成员数量\",\"t\":[\"扩展运算符（...）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。 这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。\",\"const arr = [1, 2]; function add(x: number, y: number) { // ... } add(...arr) // 报错\",\"上面示例会报错，原因是函数add()只能接受两个参数，但是传入的是...arr，TypeScript 认为转换后的参数个数是不确定的。\",\"const arr: [number, number] = [1, 2]; function add(x: number, y: number) {// ... } add(...arr) // 正确\",\"一种写法是使用as const断言。\",\"const arr = [1, 2] as const;\",\"上面这种写法也可以，因为 TypeScript 会认为arr的类型是readonly [1, 2]，这是一个只读的值类型，可以当作数组，也可以当作元组。\"]},\"87\":{\"c\":[\"TypeScript\"]},\"88\":{\"h\":\"类型工具\"},\"89\":{\"h\":\"\",\"t\":[\"Awaited<Type>用来取出 Promise 的返回值类型，适合用在描述then()方法和 await 命令的参数类型。\",\"type A = Awaited<Promise<string>>;\",\"上面示例中，Awaited<Type>会返回 Promise 的返回值类型（string）。\",\"// number type B = Awaited<Promise<Promise<number>>>;\",\"如果它的类型参数不是 Promise 类型，那么就会原样返回。\",\"// number | boolean type C = Awaited<boolean | Promise<number>>;\"]},\"90\":{\"h\":\"\",\"t\":[\"ConstructorParameters<Type>提取构造方法Type的参数类型，组成一个元组类型返回。\",\"type T1 = ConstructorParameters<new (x: string, y: number) => object>; // [x: string, y: number] type T2 = ConstructorParameters<new (x?: string) => object>; // [x?: string | undefined]\",\"它可以返回一些内置构造方法的参数类型。\",\"type T1 = ConstructorParameters<ErrorConstructor>; // [message?: string] type T2 = ConstructorParameters<FunctionConstructor>; // string[] type T3 = ConstructorParameters<RegExpConstructor>; // [pattern:string|RegExp, flags?:string]\",\"如果参数类型不是构造方法，就会报错。\",\"type T1 = ConstructorParameters<string>; // 报错type T2 = ConstructorParameters<Function>; // 报错\",\"any类型和never类型是两个特殊值，分别返回unknown[]和never。\",\"type T1 = ConstructorParameters<any>; // unknown[] type T2 = ConstructorParameters<never>; // never\",\"ConstructorParameters<Type>的实现如下。\",\"type ConstructorParameters< T extends abstract new (...args: any) => any > = T extends abstract new (...args: infer P) => any ? P : never\"]},\"91\":{\"h\":\"\",\"t\":[\"Exclude<UnionType, ExcludedMembers>用来从联合类型UnionType里面，删除某些类型ExcludedMembers，组成一个新的类型返回。\",\"type T1 = Exclude<'a' | 'b' | 'c', 'a'>; // 'b'|'c' type T2 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>; // 'c' type T3 = Exclude<string | (() => void), Function>; // string type T4 = Exclude<string | string[], any[]>; // string type T5 = Exclude<(() => void) | null, Function>; // null type T6 = Exclude<200 | 400, 200 | 201>; // 400 type T7 = Exclude<number, boolean>; // number\",\"Exclude<UnionType, ExcludedMembers>的实现如下。\",\"type Exclude<T, U> = T extends U ? never : T;\",\"上面代码中，等号右边的部分，表示先判断T是否兼容U，如果是的就返回never类型，否则返回当前类型T。由于never类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将never类型从联合类型中“消掉”，因此Exclude<T, U>就相当于删除兼容的类型，剩下不兼容的类型\"]},\"92\":{\"h\":\"\",\"t\":[\"Extract<UnionType, Union>用来从联合类型UnionType之中，提取指定类型Union，组成一个新类型返回。它与Exclude<T, U>正好相反。\",\"type T1 = Extract<'a' | 'b' | 'c', 'a'>; // 'a' type T2 = Extract<'a' | 'b' | 'c', 'a' | 'b'>; // 'a'|'b' type T3 = Extract<'a' | 'b' | 'c', 'a' | 'd'>; // 'a' type T4 = Extract<string | string[], any[]>; // string[] type T5 = Extract<(() => void) | null, Function>; // () => void type T6 = Extract<200 | 400, 200 | 201>; // 200\",\"如果参数类型Union不包含在联合类型UnionType之中，则返回never类型。\",\"type T = Extract<string | number, boolean>; // never\",\"Extract<UnionType, Union>的实现如下。\",\"type Extract<T, U> = T extends U ? T : never;\"]},\"93\":{\"h\":\"\",\"t\":[\"InstanceType<Type>提取构造函数的返回值的类型（即实例类型），参数Type是一个构造函数，等同于构造函数的ReturnType<Type>。\",\"type T = InstanceType<new () => object>; // object\",\"上面示例中，类型参数是一个构造函数new () => object，返回值是该构造函数的实例类型（object）。\",\"type A = InstanceType<ErrorConstructor>; // Error type B = InstanceType<FunctionConstructor>; // Function type C = InstanceType<RegExpConstructor>; // RegExp\",\"上面示例中，InstanceType<T>的参数都是 TypeScript 内置的原生对象的构造函数类型，InstanceType<T>的返回值就是这些构造函数的实例类型。 由于 Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用typeof运算符获取它的构造方法类型。\",\"class C { x = 0; y = 0; } type T = InstanceType<typeof C>; // C\",\"如果类型参数不是构造方法，就会报错。\",\"type T1 = InstanceType<string>; // 报错 type T2 = InstanceType<Function>; // 报错\",\"如果类型参数是any或never两个特殊值，分别返回any和never。\",\"type T1 = InstanceType<any>; // any type T2 = InstanceType<never>; // never\",\"InstanceType<Type>的实现如下。\",\"type InstanceType< T extends abstract new (...args: any) => any > = T extends abstract new (...args: any) => infer R ? R : any;\"]},\"94\":{\"h\":\"\",\"t\":[\"NonNullable<Type>用来从联合类型Type删除null类型和undefined类型，组成一个新类型返回，也就是返回Type的非空类型版本。\",\"// string|number type T1 = NonNullable<string | number | undefined>; // string[] type T2 = NonNullable<string[] | null | undefined>; type T3 = NonNullable<boolean>; // boolean type T4 = NonNullable<number | null>; // number type T5 = NonNullable<string | undefined>; // string type T6 = NonNullable<null | undefined>; // never\",\"NonNullable<Type>的实现如下。\",\"type NonNullable<T> = T & {}\",\"上面代码中，T & {}等同于求T & Object的交叉类型。由于 TypeScript 的非空值都属于Object的子类型，所以会返回自身；而null和undefined不属于Object，会返回never类型。\"]},\"95\":{\"h\":\"\",\"t\":[\"Omit<Type, Keys>用来从对象类型Type中，删除指定的属性Keys，组成一个新的对象类型返回。\",\"interface A { x: number; y: number; } type T1 = Omit<A, 'x'>; // { y: number } type T2 = Omit<A, 'y'>; // { x: number } type T3 = Omit<A, 'x' | 'y'>; // { }\",\"上面示例中，Omit<Type, Keys>从对象类型A里面删除指定属性，返回剩下的属性。 指定删除的键名Keys可以是对象类型Type中不存在的属性，但必须兼容string|number|symbol。\",\"interface A { x: number; y: number; } type T = Omit<A, 'z'>; // { x: number; y: number }\",\"上面示例中，对象类型A中不存在属性z，所以就原样返回了。Omit<Type, Keys>的实现如下。\",\"type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\"]},\"96\":{\"h\":\"\",\"t\":[\"OmitThisParameter<Type>从函数类型中移除 this 参数。\",\"function toHex(this: Number) { return this.toString(16); } type T = OmitThisParameter<typeof toHex>; // () => string\",\"上面示例中，OmitThisParameter<T>给出了函数toHex()的类型，并将其中的this参数删除。 如果函数没有 this 参数，则返回原始函数类型。OmitThisParameter<Type>的实现如下\",\"type OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T;\"]},\"97\":{\"h\":\"\",\"t\":[\"Parameters<Type>从函数类型Type里面提取参数类型，组成一个元组返回。\",\"type T1 = Parameters<() => string>; // [] type T2 = Parameters<(s: string) => void>; // [s:string] type T3 = Parameters<<T>(arg: T) => T>; // [arg: unknown] type T4 = Parameters<(x: { a: number; b: string }) => void>; // [x: { a: number, b: string }] type T5 = Parameters<(a: number, b: number) => number>; // [a:number, b:number]\",\"上面示例中，Parameters<Type>的返回值会包括函数的参数名，这一点需要注意。 如果参数类型Type不是带有参数的函数形式，会报错。\",\"// 报错 type T1 = Parameters<string>; // 报错 type T2 = Parameters<Function>;\",\"由于any和never是两个特殊值，会返回unknown[]和never。\",\"type T1 = Parameters<any>; // unknown[] type T2 = Parameters<never>; // never\",\"相关信息\",\"Parameters<Type>主要用于从外部模块提供的函数类型中，获取参数类型。\",\"interface SecretName { first: string; last: string; } interface SecretSanta { name: SecretName; gift: string; } export function getGift(name: SecretName, gift: string): SecretSanta { // ... }\",\"上面示例中，模块只输出了函数getGift()，没有输出参数SecretName和返回值SecretSanta。这时就可以通过Parameters<T>和ReturnType<T>拿到这两个接口类型\",\"type ParaT = Parameters<typeof getGift>[0]; // SecretName type ReturnT = ReturnType<typeof getGift>; // SecretSanta\",\"Parameters<Type>的实现如下。\",\"type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never\"]},\"98\":{\"h\":\"\",\"t\":[\"Partial<Type>返回一个新类型，将参数类型Type的所有属性变为可选属性。\",\"interface A { x: number; y: number; } type T = Partial<A>; // { x?: number; y?: number; }\",\"Partial<Type>的实现如下。\",\"type Partial<T> = { [P in keyof T]?: T[P]; };\"]},\"99\":{\"h\":\"\",\"t\":[\"Pick<Type, Keys>返回一个新的对象类型，第一个参数Type是一个对象类型，第二个参数Keys是Type里面被选定的键名。\",\"interface A { x: number; y: number; } type T1 = Pick<A, 'x'>; // { x: number } type T2 = Pick<A, 'y'>; // { y: number } type T3 = Pick<A, 'x' | 'y'>; // { x: number; y: number }\",\"上面示例中，Pick<Type, Keys>会从对象类型A里面挑出指定的键名，组成一个新的对象类型。 指定的键名Keys必须是对象键名Type里面已经存在的键名，否则会报错\",\"interface A { x: number; y: number; } type T = Pick<A, 'z'>; // 报错\",\"上面示例中，对象类型A不存在键名z，所以报错了。Pick<Type, Keys>的实现如下。\",\"type Pick<T, K extends keyof T> = { [P in K]: T[P]; };\"]},\"100\":{\"h\":\"\",\"t\":[\"Readonly<Type>返回一个新类型，将参数类型Type的所有属性变为只读属性。\",\"interface A { x: number; y?: number; } // { readonly x: number; readonly y?: number; } type T = Readonly<A>;\",\"上面示例中，y是可选属性，Readonly<Type>不会改变这一点，只会让y变成只读。Readonly<Type>的实现如下。\",\"type Readonly<T> = { readonly [P in keyof T]: T[P]; };\",\"我们可以自定义类型工具Mutable<Type>，将参数类型的所有属性变成可变属性。\",\"type Mutable<T> = { -readonly [P in keyof T]: T[P]; };\",\"提示\",\"上面代码中，-readonly表示去除属性的只读标志。 相应地，+readonly就表示增加只读标志，等同于readonly。因此，Readonly<Type>的实现也可以写成下面这样。\",\"type Readonly<T> = { +readonly [P in keyof T]: T[P]; };\",\"Readonly<Type>可以与Partial<Type>结合使用，将所有属性变成只读的可选属性。\",\"interface Person { name: string; age: number; } const worker: Readonly<Partial<Person>> = {name: '张三'}; worker.name = '李四'; // 报错\"]},\"101\":{\"h\":\"\",\"t\":[\"Record<Keys, Type>返回一个对象类型，参数Keys用作键名，参数Type用作键值类型。\",\"// { a: number } type T = Record<'a', number>;\",\"上面示例中，Record<Keys, Type>的第一个参数a，用作对象的键名，第二个参数number是a的键值类型。 参数Keys可以是联合类型，这时会依次展开为多个键。\",\"// { a: number, b: number } type T = Record<'a' | 'b', number>;\",\"上面示例中，第一个参数是联合类型'a'|'b'，展开成两个键名a和b。 如果参数Type是联合类型，就表明键值是联合类型。\",\"// { a: number|string } type T = Record<'a', number | string>;\",\"参数Keys的类型必须兼容string|number|symbol，否则不能用作键名，会报错。Record<Keys, Type>的实现如下。\",\"type Record<K extends string | number | symbol, T> = { [P in K]: T; }\"]},\"102\":{\"h\":\"\",\"t\":[\"Required<Type>返回一个新类型，将参数类型Type的所有属性变为必选属性。它与Partial<Type>的作用正好相反。\",\"interface A { x?: number; y: number; } type T = Required<A>; // { x: number; y: number; }\",\"Required<Type>的实现如下。\",\"type Required<T> = { [P in keyof T]-?: T[P]; };\",\"提示\",\"上面代码中，符号-?表示去除可选属性的“问号”，使其变成必选属性。 相对应地，符号+?表示增加可选属性的“问号”，等同于?。因此，前面的Partial<Type>的定义也可以写成下面这样。\",\"type Partial<T> = { [P in keyof T]+?: T[P]; };\"]},\"103\":{\"h\":\"\",\"t\":[\"ReadonlyArray<Type>用来生成一个只读数组类型，类型参数Type表示数组成员的类型。\",\"const values: ReadonlyArray<string> = ['a', 'b', 'c']; values[0] = 'x'; // 报错 values.push('x'); // 报错 values.pop(); // 报错 values.splice(1, 1); // 报错\",\"上面示例中，变量values的类型是一个只读数组，所以修改成员会报错，并且那些会修改源数组的方法push()、pop()、splice()等都不存在。ReadonlyArray<Type>的实现如下。\",\"interface ReadonlyArray<T> { readonly length: number; readonly [n: number]: T; // ... }\"]},\"104\":{\"h\":\"\",\"t\":[\"ReturnType<Type>提取函数类型Type的返回值类型，作为一个新类型返回。\",\"type T1 = ReturnType<() => string>; // string type T2 = ReturnType<() => { a: string; b: number }>; // { a: string; b: number } type T3 = ReturnType<(s: string) => void>; // void type T4 = ReturnType<() => () => any[]>; // () => any[] type T5 = ReturnType<typeof Math.random>; // number type T6 = ReturnType<typeof Array.isArray>; // boolean\",\"如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回unknown。\",\"type T1 = ReturnType<<T>() => T>; // unknown type T2 = ReturnType< <T extends U, U extends number[]>() => T >; // number[]\",\"注意\",\"如果类型不是函数，会报错。\",\"type T1 = ReturnType<boolean>; // 报错 type T2 = ReturnType<Function>; // 报错 type T1 = ReturnType<any>; // any type T2 = ReturnType<never>; // never\",\"ReturnType<Type>的实现如下。\",\" type ReturnType< T extends (...args: any) => any > = T extends (...args: any) => infer R ? R : any;\"]},\"105\":{\"h\":\"\",\"t\":[\"ThisParameterType<Type>提取函数类型中this参数的类型。\",\"function toHex(this: number) { return this.toString(16); } type T = ThisParameterType<typeof toHex>; // number\",\"如果函数没有this参数，则返回unknown。ThisParameterType<Type>的实现如下。\",\"type ThisParameterType<T> = T extends (this: infer U, ...args: never ) => any ? U : unknown;\"]},\"106\":{\"h\":\"\",\"t\":[\"ThisType<Type>不返回类型，只用来跟其他类型组成交叉类型，用来提示 TypeScript 其他类型里面的this的类型。\",\"interface HelperThisValue { logError: (error: string) => void; } let helperFunctions: { [name: string]: Function } & ThisType<HelperThisValue> = { hello: function () { this.logError(\\\"Error: Something wrong!\\\"); // 正确this.update(); // 报错 } }\",\"上面示例中，变量helperFunctions的类型是一个正常的对象类型与ThisType<HelperThisValue>组成的交叉类型。 这里的ThisType的作用是提示 TypeScript，变量helperFunctions的this应该满足HelperThisValue的条件。所以，this.logError()可以正确调用，而this.update()会报错，因为HelperThisValue里面没有这个方法。 注意，使用这个类型工具时，必须打开noImplicitThis设置。 下面是另一个例子。\",\"let obj: ThisType<{ x: number }> & { getX: () => number }; obj = { getX() { return this.x + this.y; // 报错 }, };\",\"上面示例中，getX()里面的this.y会报错，因为根据ThisType<{ x: number }>，这个对象的this不包含属性y。ThisType<Type>的实现就是一个空接口。\"]},\"107\":{\"h\":\"字符串类型工具\",\"t\":[\"TypeScript 内置了四个字符串类型工具，专门用来操作字符串类型。这四个工具类型都定义在 TypeScript 自带的.d.ts文件里面。 它们的实现都是在底层调用 JavaScript 引擎提供 JavaScript 字符操作方法。\"]},\"108\":{\"h\":\"\",\"t\":[\"Uppercase<StringType>将字符串类型的每个字符转为大写。\",\"type A = 'hello'; // \\\"HELLO\\\" type B = Uppercase<A>;\"]},\"109\":{\"h\":\"\",\"t\":[\"Lowercase<StringType>将字符串的每个字符转为小写。\",\"type A = 'HELLO'; // \\\"hello\\\" type B = Lowercase<A>;\"]},\"110\":{\"h\":\"\",\"t\":[\"Capitalize<StringType>将字符串的第一个字符转为大写。\",\"type A = 'hello'; // \\\"Hello\\\" type B = Capitalize<A>;\"]},\"111\":{\"h\":\"\",\"t\":[\"Uncapitalize<StringType> 将字符串的第一个字符转为小写。\",\"type A = 'HELLO'; // \\\"hELLO\\\" type B = Uncapitalize<A>;\"]},\"112\":{\"c\":[\"TypeScript\"]},\"113\":{\"h\":\"ces\"},\"114\":{\"c\":[\"JavaScript\"]},\"115\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"116\":{\"h\":\"Java Script\"},\"117\":{\"h\":\"Vue3\"},\"118\":{\"h\":\"Type Script\"},\"119\":{\"h\":\"Aaa\"}},\"dirtCount\":0,\"index\":[[\"自带的\",{\"1\":{\"107\":1}}],[\"专门用来操作字符串类型\",{\"1\":{\"107\":1}}],[\"符号+\",{\"1\":{\"102\":1}}],[\"符号\",{\"1\":{\"102\":1}}],[\"展开成两个键名a和b\",{\"1\":{\"101\":1}}],[\"展示\",{\"0\":{\"9\":1}}],[\"李四\",{\"1\":{\"100\":1}}],[\"张三\",{\"1\":{\"100\":1}}],[\"获取参数类型\",{\"1\":{\"97\":1}}],[\"k>>\",{\"1\":{\"95\":1}}],[\"k\",{\"1\":{\"95\":1,\"99\":2,\"101\":1}}],[\"keyof\",{\"1\":{\"95\":1,\"98\":1,\"99\":1,\"100\":3,\"102\":2}}],[\"keys>会从对象类型a里面挑出指定的键名\",{\"1\":{\"99\":1}}],[\"keys>返回一个新的对象类型\",{\"1\":{\"99\":1}}],[\"keys>的实现如下\",{\"1\":{\"95\":1,\"99\":1}}],[\"keys>从对象类型a里面删除指定属性\",{\"1\":{\"95\":1}}],[\"keys>用来从对象类型type中\",{\"1\":{\"95\":1}}],[\"key\",{\"1\":{\"36\":4}}],[\"z\",{\"1\":{\"95\":1,\"99\":1}}],[\"删除指定的属性keys\",{\"1\":{\"95\":1}}],[\"删除某些类型excludedmembers\",{\"1\":{\"91\":1}}],[\"则返回unknown\",{\"1\":{\"105\":1}}],[\"则返回原始函数类型\",{\"1\":{\"96\":1}}],[\"则返回never类型\",{\"1\":{\"92\":1}}],[\"则推断类型还是\",{\"1\":{\"61\":1}}],[\"则推断类型为\",{\"1\":{\"61\":1}}],[\"消掉\",{\"1\":{\"91\":1}}],[\"uppercase<a>\",{\"1\":{\"108\":1}}],[\"uppercase<stringtype>将字符串类型的每个字符转为大写\",{\"1\":{\"108\":1}}],[\"update\",{\"1\":{\"106\":2}}],[\"u\",{\"1\":{\"91\":1,\"92\":1,\"104\":2,\"105\":2}}],[\"u>正好相反\",{\"1\":{\"92\":1}}],[\"u>就相当于删除兼容的类型\",{\"1\":{\"91\":1}}],[\"u>\",{\"1\":{\"91\":1,\"92\":1}}],[\"uncapitalize<a>\",{\"1\":{\"111\":1}}],[\"uncapitalize<stringtype>\",{\"1\":{\"111\":1}}],[\"union>的实现如下\",{\"1\":{\"92\":1}}],[\"union>用来从联合类型uniontype之中\",{\"1\":{\"92\":1}}],[\"union\",{\"1\":{\"72\":1}}],[\"unique\",{\"0\":{\"60\":1},\"1\":{\"60\":19,\"61\":3}}],[\"undefined>\",{\"1\":{\"94\":4}}],[\"undefined和null只能赋值给自身\",{\"1\":{\"70\":1}}],[\"undefined和null就不能赋值给其他类型的变量\",{\"1\":{\"70\":1}}],[\"undefined和null既是值\",{\"1\":{\"70\":1}}],[\"undefined和null其实是两个特殊值\",{\"1\":{\"65\":1}}],[\"undefined\",{\"0\":{\"70\":1},\"1\":{\"64\":1,\"68\":1,\"70\":5,\"75\":2,\"90\":1}}],[\"unknown也可以视为所有其他类型\",{\"1\":{\"57\":1}}],[\"unknown可以看作是更安全的any\",{\"1\":{\"57\":1}}],[\"unknown类型变量才可以使用\",{\"1\":{\"57\":1}}],[\"unknown类型变量能够进行的运算是有限的\",{\"1\":{\"57\":1}}],[\"unknown类型的变量a经过typeof运算以后\",{\"1\":{\"57\":1}}],[\"unknown类型的变量a进行加法运算会报错\",{\"1\":{\"57\":1}}],[\"unknown类型的变量\",{\"1\":{\"57\":1}}],[\"unknown类型跟any类型的不同之处在于\",{\"1\":{\"57\":1}}],[\"unknown跟any的相似之处\",{\"1\":{\"57\":1}}],[\"unknown\",{\"0\":{\"57\":1},\"1\":{\"57\":8,\"90\":1,\"96\":1,\"97\":2,\"104\":1,\"105\":1}}],[\"分别返回any和never\",{\"1\":{\"93\":1}}],[\"分别返回unknown\",{\"1\":{\"90\":1}}],[\"分类为\",{\"1\":{\"27\":1}}],[\"组成一个元组返回\",{\"1\":{\"97\":1}}],[\"组成一个元组类型返回\",{\"1\":{\"90\":1}}],[\"组成一个新的对象类型\",{\"1\":{\"99\":1}}],[\"组成一个新的对象类型返回\",{\"1\":{\"95\":1}}],[\"组成一个新的类型返回\",{\"1\":{\"91\":1}}],[\"组成一个新类型返回\",{\"1\":{\"92\":1,\"94\":1}}],[\"组件\",{\"0\":{\"22\":1,\"29\":1},\"1\":{\"29\":1}}],[\"适合用在描述then\",{\"1\":{\"89\":1}}],[\"适配\",{\"1\":{\"46\":1}}],[\"转换成一个逗号分隔的序列\",{\"1\":{\"86\":1}}],[\"成员数量的推断\",{\"0\":{\"85\":1}}],[\"读取成员类型\",{\"1\":{\"83\":1}}],[\"越界的成员会报错\",{\"1\":{\"83\":1}}],[\"越是大型的\",{\"1\":{\"45\":1}}],[\"问号\",{\"1\":{\"102\":2}}],[\"问号只能用于元组的尾部成员\",{\"1\":{\"83\":1}}],[\"问题就这样留到运行时才会暴露\",{\"1\":{\"56\":1}}],[\"特有的数据类型\",{\"1\":{\"83\":1}}],[\"特殊类型\",{\"0\":{\"54\":1}}],[\"元组也可以是只读的\",{\"1\":{\"84\":1}}],[\"元组可以通过方括号\",{\"1\":{\"83\":1}}],[\"元组的成员可以添加成员名\",{\"1\":{\"83\":1}}],[\"元组的成员数量是有限的\",{\"1\":{\"83\":1}}],[\"元组包含多少个成员\",{\"1\":{\"83\":1}}],[\"元组成员的类型可以添加问号后缀\",{\"1\":{\"83\":1}}],[\"元组\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"多维数组\",{\"0\":{\"82\":1}}],[\"多人合作的项目\",{\"1\":{\"45\":1}}],[\"反过来就不行\",{\"1\":{\"81\":1}}],[\"反过来是可以的\",{\"1\":{\"71\":1}}],[\"子类型number\",{\"1\":{\"81\":1}}],[\"子类型继承了父类型的所有特征\",{\"1\":{\"81\":1}}],[\"子类型可以赋值给父类型\",{\"1\":{\"71\":1}}],[\"之类会改变原数组的方法\",{\"1\":{\"81\":1}}],[\"修改const命令声明的数组的成员是允许的\",{\"1\":{\"81\":1}}],[\"修改他人的\",{\"1\":{\"45\":1}}],[\"断言\",{\"0\":{\"81\":1}}],[\"允许声明只读数组\",{\"1\":{\"81\":1}}],[\"允许使用方括号读取数组成员的类型\",{\"1\":{\"79\":1}}],[\"允许你存储和检索用键索引的对象可以存储结构化克隆算法支持的任何对象\",{\"1\":{\"35\":1}}],[\"块级类型声明\",{\"0\":{\"76\":1}}],[\"同一段代码可能存在两种typeof运算符\",{\"1\":{\"75\":1}}],[\"同时每个页面包含\",{\"1\":{\"6\":1}}],[\"`\",{\"1\":{\"74\":1}}],[\"`hello\",{\"1\":{\"74\":1}}],[\"`1`\",{\"1\":{\"36\":1}}],[\"影响不到外部\",{\"1\":{\"74\":1}}],[\"别名支持使用表达式\",{\"1\":{\"74\":1}}],[\"别名的作用域是块级作用域\",{\"1\":{\"74\":1}}],[\"别名不允许重名\",{\"1\":{\"74\":1}}],[\"交叉类型a\",{\"1\":{\"73\":1}}],[\"交叉类型\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"紫\",{\"1\":{\"72\":1}}],[\"蓝\",{\"1\":{\"72\":1}}],[\"青\",{\"1\":{\"72\":1}}],[\"绿\",{\"1\":{\"72\":1}}],[\"黄\",{\"1\":{\"72\":1}}],[\"橙\",{\"1\":{\"72\":1}}],[\"赤\",{\"1\":{\"72\":1}}],[\"联合类型a|b表示\",{\"1\":{\"72\":1}}],[\"联合类型\",{\"0\":{\"72\":1},\"1\":{\"72\":1}}],[\"父类型不能赋值给子类型\",{\"1\":{\"71\":1}}],[\"推测为number\",{\"1\":{\"71\":1}}],[\"推断为\",{\"1\":{\"80\":1}}],[\"推断行为会因为值的不同\",{\"1\":{\"80\":1}}],[\"推断类型时\",{\"1\":{\"71\":1}}],[\"推断类型为\",{\"1\":{\"61\":2,\"80\":3}}],[\"推断它的类型为number\",{\"1\":{\"50\":1}}],[\"404\",{\"1\":{\"115\":1}}],[\"400\",{\"1\":{\"91\":2,\"92\":1}}],[\"4\",{\"1\":{\"71\":2}}],[\"42\",{\"1\":{\"57\":1}}],[\"55\",{\"1\":{\"74\":1}}],[\"5\",{\"1\":{\"71\":3,\"74\":1,\"76\":1}}],[\"5是一个具体的数值\",{\"1\":{\"60\":1}}],[\"遇到const命令声明的变量\",{\"1\":{\"71\":1}}],[\"遇到这种情况是不报错的\",{\"1\":{\"45\":1}}],[\"称为\",{\"1\":{\"71\":1}}],[\"规定\",{\"1\":{\"71\":1}}],[\"及早发现错误\",{\"1\":{\"70\":1}}],[\"又是类型\",{\"1\":{\"70\":1}}],[\"用来提示\",{\"1\":{\"106\":1}}],[\"用作对象的键名\",{\"1\":{\"101\":1}}],[\"用在元组的任意位置都可以\",{\"1\":{\"83\":1}}],[\"用大括号表示\",{\"1\":{\"76\":1}}],[\"用户自定义的属性和方法都不存在于这两个类型之中\",{\"1\":{\"69\":1}}],[\"用于在客户端存储大量的结构化数据\",{\"1\":{\"35\":1}}],[\"内置了四个字符串类型工具\",{\"1\":{\"107\":1}}],[\"内置的原生对象的构造函数类型\",{\"1\":{\"93\":1}}],[\"内置对象原生的属性和方法\",{\"1\":{\"69\":1}}],[\"内容\",{\"1\":{\"12\":1}}],[\"无论是大写的object类型\",{\"1\":{\"69\":1}}],[\"无法推断出它们的类型\",{\"1\":{\"56\":1}}],[\"无法提前知道变量的类型是什么\",{\"1\":{\"44\":1}}],[\"建议总是使用小写类型object\",{\"1\":{\"69\":1}}],[\"建议使用let和var声明变量时\",{\"1\":{\"56\":1}}],[\"我们可以自定义类型工具mutable<type>\",{\"1\":{\"100\":1}}],[\"我们使用对象类型\",{\"1\":{\"69\":1}}],[\"我们一般都会想到cookie\",{\"1\":{\"35\":1}}],[\"数组的类型推断\",{\"0\":{\"80\":1}}],[\"数组\",{\"0\":{\"79\":1}}],[\"数组与元组\",{\"0\":{\"78\":1}}],[\"数组和函数\",{\"1\":{\"69\":1}}],[\"数值\",{\"1\":{\"43\":1}}],[\"小写的object类型代表\",{\"1\":{\"69\":1}}],[\"事实上\",{\"1\":{\"68\":1}}],[\"没有输出参数secretname和返回值secretsanta\",{\"1\":{\"97\":1}}],[\"没有实际作用\",{\"1\":{\"83\":1}}],[\"没有单独区分这种类型\",{\"1\":{\"83\":1}}],[\"没有使用意义\",{\"1\":{\"66\":1}}],[\"没法提前知道\",{\"1\":{\"44\":1}}],[\"除了undefined和null这两个值不能转为对象\",{\"1\":{\"68\":1}}],[\"除了any\",{\"1\":{\"57\":1}}],[\"除了any类型和unknown类型\",{\"1\":{\"57\":1,\"70\":1}}],[\"除非使用下面的写法\",{\"1\":{\"66\":1}}],[\"第二个参数number是a的键值类型\",{\"1\":{\"101\":1}}],[\"第二个参数keys是type里面被选定的键名\",{\"1\":{\"99\":1}}],[\"第二行是包装对象\",{\"1\":{\"66\":1}}],[\"第一个参数是联合类型\",{\"1\":{\"101\":1}}],[\"第一个参数type是一个对象类型\",{\"1\":{\"99\":1}}],[\"第一行是字面量\",{\"1\":{\"66\":1}}],[\"字符操作方法\",{\"1\":{\"107\":1}}],[\"字符串类型工具\",{\"0\":{\"107\":1}}],[\"字符串会自动转为包装对象\",{\"1\":{\"65\":1}}],[\"字符串hello执行了charat\",{\"1\":{\"65\":1}}],[\"字面量new\",{\"1\":{\"66\":1}}],[\"五种包装对象之中\",{\"1\":{\"65\":1}}],[\"代表实例类型\",{\"1\":{\"93\":1}}],[\"代表操作数的类型\",{\"1\":{\"75\":1}}],[\"代表最基本的\",{\"1\":{\"65\":1}}],[\"代码部分\",{\"1\":{\"75\":2}}],[\"代码块内部定义的别名\",{\"1\":{\"74\":1}}],[\"代码看看结果\",{\"1\":{\"52\":1}}],[\"代码最明显的特征\",{\"1\":{\"49\":1}}],[\"代码转成\",{\"1\":{\"46\":1}}],[\"代码也许就会原样发布\",{\"1\":{\"43\":1}}],[\"代码\",{\"1\":{\"43\":1,\"44\":1,\"45\":2,\"46\":2,\"52\":2}}],[\"继承了\",{\"1\":{\"64\":1}}],[\"静态只读属性foo的类型就是unique\",{\"1\":{\"60\":1}}],[\"静态类型将这些灵活性都剥夺了\",{\"1\":{\"46\":1}}],[\"静态类型也存在一些缺点\",{\"1\":{\"46\":1}}],[\"静态类型的缺点\",{\"0\":{\"46\":1}}],[\"静态类型的优点\",{\"0\":{\"45\":1}}],[\"静态类型有很多好处\",{\"1\":{\"45\":1}}],[\"等都不存在\",{\"1\":{\"103\":1}}],[\"等同于\",{\"1\":{\"102\":1}}],[\"等同于readonly\",{\"1\":{\"100\":1}}],[\"等同于求t\",{\"1\":{\"94\":1}}],[\"等同于构造函数的returntype<type>\",{\"1\":{\"93\":1}}],[\"等同于const\",{\"1\":{\"60\":1}}],[\"等号右边的部分\",{\"1\":{\"91\":1}}],[\"等号右侧4\",{\"1\":{\"71\":1}}],[\"等号左侧的类型是数值5\",{\"1\":{\"71\":1}}],[\"等于同一个\",{\"1\":{\"60\":1}}],[\"目前无法识别这种情况\",{\"1\":{\"60\":1}}],[\"相对应地\",{\"1\":{\"102\":1}}],[\"相应地\",{\"1\":{\"100\":1}}],[\"相关信息\",{\"1\":{\"83\":1,\"97\":1}}],[\"相当于\",{\"1\":{\"81\":1}}],[\"相当于vue2\",{\"0\":{\"39\":1}}],[\"相同参数的symbol\",{\"1\":{\"60\":1}}],[\"类似于字符串\",{\"1\":{\"60\":1}}],[\"类型参数type表示数组成员的类型\",{\"1\":{\"103\":1}}],[\"类型参数是一个构造函数new\",{\"1\":{\"93\":1}}],[\"类型工具\",{\"0\":{\"88\":1}}],[\"类型与\",{\"0\":{\"67\":1}}],[\"类型无法直接获取它们的包装对象\",{\"1\":{\"65\":1}}],[\"类型和\",{\"1\":{\"65\":1,\"66\":1}}],[\"类型大全\",{\"0\":{\"63\":1}}],[\"类型为\",{\"1\":{\"61\":4}}],[\"类型为数值\",{\"1\":{\"43\":1}}],[\"类型是\",{\"1\":{\"60\":1}}],[\"类型是人为添加的一种编程约束和用法提示\",{\"1\":{\"43\":1}}],[\"类型的包装对象\",{\"1\":{\"66\":1}}],[\"类型的一个作用\",{\"1\":{\"60\":1}}],[\"类型的子类型\",{\"1\":{\"60\":1}}],[\"类型的变量\",{\"1\":{\"60\":1,\"61\":2}}],[\"类型的概念\",{\"0\":{\"43\":1}}],[\"类型缩小以后再使用\",{\"1\":{\"57\":1}}],[\"类型缩小\",{\"1\":{\"57\":3}}],[\"类型表示没有任何限制\",{\"1\":{\"56\":1}}],[\"类型推断就不会更新\",{\"1\":{\"80\":1}}],[\"类型推断的自动更新只发生初始值为空数组的情况\",{\"1\":{\"80\":1}}],[\"类型推断问题\",{\"1\":{\"56\":1}}],[\"类型推断\",{\"0\":{\"50\":1,\"61\":1}}],[\"类型声明并不是必需的\",{\"1\":{\"50\":1}}],[\"类型声明的写法\",{\"1\":{\"49\":1}}],[\"类型声明\",{\"0\":{\"49\":1}}],[\"类型系统通常比较复杂\",{\"1\":{\"46\":1}}],[\"类型信息能够提供的帮助越大\",{\"1\":{\"45\":1}}],[\"类型信息大大减轻了重构的成本\",{\"1\":{\"45\":1}}],[\"类型信息可以部分替代代码文档\",{\"1\":{\"45\":1}}],[\"类型\",{\"0\":{\"57\":1,\"58\":1,\"67\":1,\"68\":1,\"69\":1},\"1\":{\"43\":1,\"49\":1,\"58\":1,\"75\":2,\"89\":1}}],[\"某个具体的\",{\"1\":{\"60\":1}}],[\"设计了symbol的一个子类型unique\",{\"1\":{\"60\":1}}],[\"设置某个数据仓库\",{\"1\":{\"36\":1}}],[\"里面的this\",{\"1\":{\"106\":1}}],[\"里面的狭义对象\",{\"1\":{\"69\":1}}],[\"里面\",{\"1\":{\"59\":1,\"75\":1,\"76\":1}}],[\"里面都会报错\",{\"1\":{\"44\":1}}],[\"值类型可能会出现一些很奇怪的报错\",{\"1\":{\"71\":1}}],[\"值类型\",{\"0\":{\"71\":1},\"1\":{\"71\":1}}],[\"值变量的类型\",{\"1\":{\"61\":1}}],[\"值当作属性名\",{\"1\":{\"60\":1}}],[\"值时\",{\"1\":{\"60\":1}}],[\"值的情况\",{\"1\":{\"60\":1}}],[\"值的那种值类型\",{\"1\":{\"60\":1}}],[\"值的类型是数值\",{\"1\":{\"44\":1}}],[\"值不存在字面量\",{\"1\":{\"60\":1}}],[\"值\",{\"1\":{\"60\":4}}],[\"值通过symbol\",{\"1\":{\"59\":1}}],[\"与其他任何值都不相等\",{\"1\":{\"59\":1}}],[\"新引入的一种原始类型的值\",{\"1\":{\"59\":1}}],[\"底层类型\",{\"1\":{\"58\":2}}],[\"把这种情况称为\",{\"1\":{\"58\":1}}],[\"把错误留到运行时\",{\"1\":{\"56\":1}}],[\"任何一个类型必须同时属于a和b\",{\"1\":{\"73\":1}}],[\"任何一个类型只要属于a或b\",{\"1\":{\"72\":1}}],[\"任何类型都包含了never类型\",{\"1\":{\"58\":1}}],[\"任务列表\",{\"0\":{\"19\":1}}],[\"空对象\",{\"1\":{\"68\":1}}],[\"空集是任何集合的子集\",{\"1\":{\"58\":1}}],[\"空类型\",{\"1\":{\"58\":2}}],[\"各种其他类型的变量都可以赋值为f\",{\"1\":{\"58\":1}}],[\"剩下不兼容的类型\",{\"1\":{\"91\":1}}],[\"剩下的五种属于原始类型\",{\"1\":{\"65\":1}}],[\"剩下的最后那个else分支里面\",{\"1\":{\"58\":1}}],[\"剩余的情况就属于never类型\",{\"1\":{\"58\":1}}],[\"判断了这两种情况后\",{\"1\":{\"58\":1}}],[\"|\",{\"1\":{\"58\":1,\"72\":10,\"79\":2,\"89\":2,\"90\":1,\"91\":11,\"92\":14,\"94\":7,\"95\":1,\"99\":1,\"101\":5}}],[\"||\",{\"1\":{\"57\":1}}],[\"处理所有可能的类型之后\",{\"1\":{\"58\":1}}],[\"详见\",{\"1\":{\"58\":1}}],[\"详见后面章节\",{\"1\":{\"58\":1}}],[\"另一种用在类型相关的\",{\"1\":{\"75\":1}}],[\"另一方面\",{\"1\":{\"43\":1}}],[\"另外\",{\"1\":{\"58\":1}}],[\"保证类型运算的完整性\",{\"1\":{\"58\":1}}],[\"保证代码安全\",{\"1\":{\"45\":1}}],[\"通常需要使用分支处理每一种类型\",{\"1\":{\"58\":1}}],[\"通常都应该优先考虑设为unknown类型\",{\"1\":{\"57\":1}}],[\"通过\",{\"1\":{\"11\":1,\"14\":1}}],[\"才属于交叉类型a\",{\"1\":{\"73\":1}}],[\"才允许使用它\",{\"1\":{\"57\":1}}],[\"才能调用它的length属性\",{\"1\":{\"57\":1}}],[\"确定变量s的类型为字符串以后\",{\"1\":{\"57\":1}}],[\"确保不会出错\",{\"1\":{\"57\":1}}],[\"确保类型正确\",{\"1\":{\"46\":1}}],[\"能够确定实际类型是number\",{\"1\":{\"57\":1}}],[\"答案是只有经过\",{\"1\":{\"57\":1}}],[\"那么就会原样返回\",{\"1\":{\"89\":1}}],[\"那么它的类型只能是\",{\"1\":{\"60\":1}}],[\"那么\",{\"1\":{\"57\":1,\"80\":1}}],[\"取反运算\",{\"1\":{\"57\":1}}],[\"取值的时候需要经过反序列化\",{\"1\":{\"35\":1}}],[\"再次\",{\"1\":{\"57\":1}}],[\"直接调用unknown类型变量的属性和方法\",{\"1\":{\"57\":1}}],[\"其实属于两个值类型\",{\"1\":{\"60\":1}}],[\"其他类型里面的this的类型\",{\"1\":{\"106\":1}}],[\"其他类型的变量不能赋值为undefined或null\",{\"1\":{\"72\":1}}],[\"其他任何值都可以赋值给object类型\",{\"1\":{\"68\":1}}],[\"其他运算都会报错\",{\"1\":{\"57\":1}}],[\"其他变量的问题\",{\"1\":{\"57\":1}}],[\"其他变量\",{\"1\":{\"56\":1,\"57\":1}}],[\"其次\",{\"1\":{\"57\":1}}],[\"首先\",{\"1\":{\"57\":1}}],[\"可能发生参数数量与数组长度不匹配的报错\",{\"1\":{\"86\":1}}],[\"可能是任意类型\",{\"1\":{\"57\":1}}],[\"可以正确调用\",{\"1\":{\"106\":1}}],[\"可以当作数组\",{\"1\":{\"86\":1}}],[\"可以任意取名\",{\"1\":{\"83\":1}}],[\"可以写成下面这样\",{\"1\":{\"83\":1}}],[\"可以写在圆括号里面\",{\"1\":{\"79\":1}}],[\"可以表示不限成员数量的元组\",{\"1\":{\"83\":1}}],[\"可以用于所有使用父类型的场合\",{\"1\":{\"81\":1}}],[\"可以是无限数量的成员\",{\"1\":{\"79\":1}}],[\"可以参考下面的例子来理解\",{\"1\":{\"60\":1}}],[\"可以赋值给父类型readonly\",{\"1\":{\"81\":1}}],[\"可以赋值给任意其他类型\",{\"1\":{\"58\":1}}],[\"可以赋值为各种类型的值\",{\"1\":{\"57\":1}}],[\"可以视为严格版的any\",{\"1\":{\"57\":1}}],[\"可以顺利通过编译\",{\"1\":{\"56\":1}}],[\"可以把变量类型设为any\",{\"1\":{\"56\":1}}],[\"可以按下\",{\"1\":{\"52\":1}}],[\"可以逐行输入代码运行\",{\"1\":{\"52\":1}}],[\"可以先全局安装它\",{\"1\":{\"52\":1}}],[\"可以直接将never类型从联合类型中\",{\"1\":{\"91\":1}}],[\"可以直接运行\",{\"1\":{\"52\":1}}],[\"可以直接在\",{\"1\":{\"46\":1}}],[\"可以告诉开发者这个函数怎么用\",{\"1\":{\"43\":1}}],[\"可以这样理解\",{\"1\":{\"43\":1}}],[\"可以进行该类型的所有运算\",{\"1\":{\"43\":1}}],[\"可以看成是\",{\"1\":{\"42\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"9\":1}}],[\"表示增加可选属性的\",{\"1\":{\"102\":1}}],[\"表示去除可选属性的\",{\"1\":{\"102\":1}}],[\"表示先判断t是否兼容u\",{\"1\":{\"91\":1}}],[\"表示该成员是可选的\",{\"1\":{\"83\":1}}],[\"表示二维数组\",{\"1\":{\"82\":1}}],[\"表示\",{\"1\":{\"73\":1}}],[\"表示类型不确定\",{\"1\":{\"57\":1}}],[\"表示这是一个数值变量\",{\"1\":{\"56\":1}}],[\"表示这个位置只能使用数值\",{\"1\":{\"43\":1}}],[\"然后用typeof运算符获取它的构造方法类型\",{\"1\":{\"93\":1}}],[\"然后\",{\"1\":{\"56\":1}}],[\"然后调用该函数\",{\"1\":{\"52\":1}}],[\"实际的值是一个字符串\",{\"1\":{\"56\":1}}],[\"实际开发中\",{\"1\":{\"56\":1}}],[\"污染其他具有正确类型的变量\",{\"1\":{\"56\":1}}],[\"污染\",{\"1\":{\"56\":1,\"57\":2}}],[\"污染问题\",{\"1\":{\"56\":1}}],[\"声明时必须同时赋值\",{\"1\":{\"56\":1}}],[\"声明了返回值的类型是string\",{\"1\":{\"49\":1}}],[\"声明了它的类型为string\",{\"1\":{\"49\":1}}],[\"赋值给any和unknown以外类型的变量都会报错\",{\"1\":{\"57\":1}}],[\"赋值\",{\"1\":{\"56\":1}}],[\"必须打开noimplicitthis设置\",{\"1\":{\"106\":1}}],[\"必须把它当成值\",{\"1\":{\"93\":1}}],[\"必须通过变量来引用\",{\"1\":{\"60\":1}}],[\"必须同时进行初始化\",{\"1\":{\"56\":1}}],[\"必须自己推断类型的那些变量\",{\"1\":{\"56\":1}}],[\"否则不能用作键名\",{\"1\":{\"101\":1}}],[\"否则会报错\",{\"1\":{\"99\":1}}],[\"否则返回当前类型t\",{\"1\":{\"91\":1}}],[\"否则因为竖杠|的优先级低于\",{\"1\":{\"79\":1}}],[\"否则都会报错\",{\"1\":{\"58\":1}}],[\"否则报错\",{\"1\":{\"56\":1}}],[\"否则可能存在安全隐患\",{\"1\":{\"56\":1}}],[\"否则就失去了使用\",{\"1\":{\"56\":1}}],[\"但必须兼容string|number|symbol\",{\"1\":{\"95\":1}}],[\"但只能赋值给类的readonly\",{\"1\":{\"60\":1}}],[\"但其实是两个值类型\",{\"1\":{\"60\":1}}],[\"但不赋值也不指定类型\",{\"1\":{\"56\":1}}],[\"但是传入的是\",{\"1\":{\"86\":1}}],[\"但是反过来就会报错\",{\"1\":{\"81\":1}}],[\"但是反过来就不行\",{\"1\":{\"60\":1}}],[\"但是成员数量是不确定的\",{\"1\":{\"79\":1}}],[\"但是返回的不是字符串\",{\"1\":{\"75\":1}}],[\"但是有时候\",{\"1\":{\"70\":1}}],[\"但是完全没有使用的理由\",{\"1\":{\"66\":1}}],[\"但是剩下三种可以\",{\"1\":{\"65\":1}}],[\"但是y的类型是\",{\"1\":{\"60\":1}}],[\"但是属于不同的值类型\",{\"1\":{\"60\":1}}],[\"但是无法表示某一个具体的\",{\"1\":{\"60\":1}}],[\"但是每一个symbol值都是独一无二的\",{\"1\":{\"59\":1}}],[\"但是它的使用有一些限制\",{\"1\":{\"57\":1}}],[\"但是它被赋值为x\",{\"1\":{\"56\":1}}],[\"但是不报错\",{\"1\":{\"56\":1}}],[\"但是把它当作函数调用\",{\"1\":{\"56\":1}}],[\"但是没有意义\",{\"1\":{\"45\":1}}],[\"但是这个属性是可以删掉的\",{\"1\":{\"44\":1}}],[\"但是后面可以改成字符串\",{\"1\":{\"44\":1}}],[\"但是\",{\"1\":{\"44\":1,\"46\":1,\"57\":1,\"58\":1,\"60\":1,\"61\":1,\"65\":1,\"66\":1,\"71\":1,\"81\":1}}],[\"但是可能会报错\",{\"1\":{\"42\":1}}],[\"打开编译选项strictnullchecks后\",{\"1\":{\"72\":1}}],[\"打开strictnullchecks以后\",{\"1\":{\"70\":1}}],[\"打开\",{\"1\":{\"70\":1}}],[\"打开该选项\",{\"1\":{\"56\":1}}],[\"打印按钮\",{\"1\":{\"6\":1}}],[\"防止像any那样可以随意乱用\",{\"1\":{\"57\":1}}],[\"防止被推断为any\",{\"1\":{\"56\":1}}],[\"防抖\",{\"1\":{\"37\":1}}],[\"怎么才能使用unknown类型变量呢\",{\"1\":{\"57\":1}}],[\"怎么用都可以\",{\"1\":{\"56\":1}}],[\"怎么使用都可以\",{\"1\":{\"56\":1}}],[\"进行比较运算就是可以的\",{\"1\":{\"57\":1}}],[\"进行类型检查了\",{\"1\":{\"56\":1}}],[\"进行引用\",{\"1\":{\"28\":1}}],[\"以上8种类型可以看作\",{\"1\":{\"64\":1}}],[\"以及类型运算的完整性\",{\"1\":{\"58\":1}}],[\"以至于后面就不再对函数add\",{\"1\":{\"56\":1}}],[\"以便\",{\"1\":{\"9\":1}}],[\"3\",{\"1\":{\"56\":1,\"57\":1,\"79\":2,\"81\":2,\"82\":1,\"83\":1,\"85\":1}}],[\"意为涵盖了所有下层\",{\"1\":{\"56\":1}}],[\"顶层类型\",{\"1\":{\"56\":1,\"58\":1}}],[\"将字符串的第一个字符转为小写\",{\"1\":{\"111\":1}}],[\"将所有属性变成只读的可选属性\",{\"1\":{\"100\":1}}],[\"将参数类型的所有属性变成可变属性\",{\"1\":{\"100\":1}}],[\"将参数类型type的所有属性变为必选属性\",{\"1\":{\"102\":1}}],[\"将参数类型type的所有属性变为只读属性\",{\"1\":{\"100\":1}}],[\"将参数类型type的所有属性变为可选属性\",{\"1\":{\"98\":1}}],[\"将数组\",{\"1\":{\"86\":1}}],[\"将typeof运算符移植到了类型运算\",{\"1\":{\"75\":1}}],[\"将值分成8种类型\",{\"1\":{\"64\":1}}],[\"将这种类型称为\",{\"1\":{\"56\":1}}],[\"将你的个人介绍和档案放置在此处\",{\"1\":{\"0\":1}}],[\"包装对象\",{\"1\":{\"65\":1,\"66\":1}}],[\"包装对象类型与字面量类型\",{\"0\":{\"66\":1}}],[\"包装对象类型\",{\"0\":{\"65\":1}}],[\"包含了一切可能的类型\",{\"1\":{\"56\":1}}],[\"包括文件和二进制对象\",{\"1\":{\"35\":1}}],[\"从类型声明就可以明确知道\",{\"1\":{\"83\":1}}],[\"从集合论的角度看\",{\"1\":{\"56\":1}}],[\"从而克服了any类型的一大缺点\",{\"1\":{\"57\":1}}],[\"从而在不安装的情况下\",{\"1\":{\"52\":1}}],[\"从而推断代码有没有错误\",{\"1\":{\"45\":1}}],[\"认为转换后的参数个数是不确定的\",{\"1\":{\"86\":1}}],[\"认为\",{\"1\":{\"56\":1}}],[\"总之\",{\"1\":{\"56\":1,\"57\":1,\"58\":1,\"70\":1}}],[\"总的来说\",{\"1\":{\"46\":1}}],[\"很多时候确实有声明为只读数组的需求\",{\"1\":{\"81\":1}}],[\"很多工具能够直接生成文档\",{\"1\":{\"45\":1}}],[\"很难为每一行适配正确的类型\",{\"1\":{\"56\":1}}],[\"尤其是别人的代码\",{\"1\":{\"56\":1}}],[\"让代码快速迁移到\",{\"1\":{\"56\":1}}],[\"需要运算才知道结果\",{\"1\":{\"75\":1}}],[\"需要关闭某些变量的类型检查\",{\"1\":{\"56\":1}}],[\"需要用到很多外部模块\",{\"1\":{\"46\":1}}],[\"出于特殊原因\",{\"1\":{\"56\":1}}],[\"应该尽量避免使用any类型\",{\"1\":{\"56\":1}}],[\"原因是函数add\",{\"1\":{\"86\":1}}],[\"原因是\",{\"1\":{\"75\":1}}],[\"原因就是x的类型是any\",{\"1\":{\"56\":1}}],[\"原始类型的值本身没有方法\",{\"1\":{\"65\":1}}],[\"原生的\",{\"1\":{\"46\":1}}],[\"编译不报错\",{\"1\":{\"70\":1}}],[\"编译时就不会报错\",{\"1\":{\"56\":1}}],[\"编译时都不报错\",{\"1\":{\"56\":1}}],[\"编辑器补全后面的部分\",{\"1\":{\"45\":1}}],[\"编辑器自动提示函数用法\",{\"1\":{\"45\":1}}],[\"编辑此页链接\",{\"1\":{\"3\":1}}],[\"或者any类型和unknown类型的变量\",{\"1\":{\"70\":1}}],[\"或者直接当作函数执行\",{\"1\":{\"57\":1}}],[\"或者当作对象读取任意属性\",{\"1\":{\"56\":1}}],[\"或者输入\",{\"1\":{\"52\":1}}],[\"都只包含\",{\"1\":{\"69\":1}}],[\"都是object类型\",{\"1\":{\"68\":1}}],[\"都有对应的包装对象\",{\"1\":{\"65\":1}}],[\"都会报错\",{\"1\":{\"57\":1}}],[\"都没有足够的信息\",{\"1\":{\"56\":1}}],[\"都不会报错\",{\"1\":{\"56\":1}}],[\"都可以使用这个值\",{\"1\":{\"43\":1}}],[\"正确this\",{\"1\":{\"106\":1}}],[\"正确\",{\"1\":{\"56\":3,\"57\":6,\"60\":4,\"66\":3,\"70\":2,\"71\":2,\"72\":2,\"81\":1,\"86\":1}}],[\"正是因为存在这些动态变化\",{\"1\":{\"44\":1}}],[\"该类型的变量可以赋予任意类型的值\",{\"1\":{\"56\":1}}],[\"基本类型\",{\"0\":{\"64\":1}}],[\"基本意义\",{\"0\":{\"56\":1}}],[\"基本用法\",{\"0\":{\"48\":1}}],[\"环境\",{\"1\":{\"52\":1}}],[\"环境中\",{\"1\":{\"52\":1}}],[\"先输入一个函数twice\",{\"1\":{\"52\":1}}],[\"命令的参数类型\",{\"1\":{\"89\":1}}],[\"命令\",{\"0\":{\"74\":1}}],[\"命令行\",{\"1\":{\"52\":1}}],[\"命令不带有任何参数\",{\"1\":{\"52\":1}}],[\">\",{\"1\":{\"52\":1,\"81\":1,\"84\":1,\"90\":1,\"91\":3,\"92\":4,\"93\":1,\"95\":4,\"99\":4,\"104\":5,\"106\":2}}],[\"单个值也是一种类型\",{\"1\":{\"71\":1}}],[\"单独运行ts\",{\"1\":{\"52\":1}}],[\"单单在开发阶段运行静态检查\",{\"1\":{\"45\":1}}],[\"逐行执行\",{\"1\":{\"52\":1}}],[\"运算符是一个一元运算符\",{\"1\":{\"75\":1}}],[\"运算符\",{\"0\":{\"75\":1},\"1\":{\"57\":1}}],[\"运算符==\",{\"1\":{\"57\":1}}],[\"运算符可以接受各种类型的值\",{\"1\":{\"44\":1}}],[\"运行就报错\",{\"1\":{\"70\":1}}],[\"运行环境\",{\"1\":{\"52\":2}}],[\"运行script\",{\"1\":{\"52\":1}}],[\"调用它来运行\",{\"1\":{\"52\":1}}],[\"给出运行结果\",{\"1\":{\"52\":1}}],[\"给予程序员很大的自由\",{\"1\":{\"46\":1}}],[\"安装后\",{\"1\":{\"52\":1}}],[\"gift\",{\"1\":{\"97\":2}}],[\"green\",{\"1\":{\"83\":1}}],[\"greeting\",{\"1\":{\"74\":1}}],[\"getx\",{\"1\":{\"106\":3}}],[\"getgift>\",{\"1\":{\"97\":2}}],[\"getgift\",{\"1\":{\"97\":1}}],[\"getsum\",{\"1\":{\"81\":2}}],[\"getitem\",{\"1\":{\"36\":1}}],[\"gender\",{\"1\":{\"72\":1}}],[\"g\",{\"1\":{\"52\":1}}],[\"$\",{\"1\":{\"52\":5,\"56\":1,\"74\":1}}],[\"$$\",{\"1\":{\"18\":2}}],[\"模块只输出了函数getgift\",{\"1\":{\"97\":1}}],[\"模块\",{\"0\":{\"52\":1},\"1\":{\"52\":1}}],[\"叫做\",{\"1\":{\"51\":1}}],[\"最简单的\",{\"1\":{\"51\":1}}],[\"跟推断的类型不一致\",{\"1\":{\"50\":1}}],[\"后面\",{\"1\":{\"50\":1}}],[\"后面就不允许再赋值为其他类型的值\",{\"1\":{\"44\":1}}],[\"由于any和never是两个特殊值\",{\"1\":{\"97\":1}}],[\"由于never类型是任何其他类型的子类型\",{\"1\":{\"91\":1}}],[\"由于需要声明每个成员的类型\",{\"1\":{\"83\":1}}],[\"由于数组成员的索引类型都是number\",{\"1\":{\"79\":1}}],[\"由于5是number的子类型\",{\"1\":{\"71\":1}}],[\"由于包装对象的存在\",{\"1\":{\"66\":1}}],[\"由于变量a和b是两个类型\",{\"1\":{\"60\":1}}],[\"由于\",{\"1\":{\"60\":1,\"93\":1,\"94\":1}}],[\"由于不存在任何属于\",{\"1\":{\"58\":1}}],[\"由于这个原因\",{\"1\":{\"56\":2}}],[\"由于它被赋值为一个数值\",{\"1\":{\"50\":1}}],[\"由于每个值\",{\"1\":{\"45\":1}}],[\"会返回unknown\",{\"1\":{\"97\":1}}],[\"会返回never类型\",{\"1\":{\"94\":1}}],[\"会报错\",{\"1\":{\"97\":1,\"101\":1,\"104\":1,\"106\":1}}],[\"会认为arr的类型是readonly\",{\"1\":{\"86\":1}}],[\"会认为这个序列的成员数量是不确定的\",{\"1\":{\"86\":1}}],[\"会认为x的类型实际是never\",{\"1\":{\"73\":1}}],[\"会自动产生的对象\",{\"1\":{\"65\":1}}],[\"会自己推断类型\",{\"1\":{\"50\":1}}],[\"会推断出元组的成员数量\",{\"1\":{\"85\":1}}],[\"会推断数组类型是any\",{\"1\":{\"80\":1}}],[\"会推断某个\",{\"1\":{\"61\":1}}],[\"会推断它们的类型为any\",{\"1\":{\"56\":1}}],[\"会抛出错误\",{\"1\":{\"58\":1}}],[\"会给出一个大于号\",{\"1\":{\"52\":1}}],[\"会使用\",{\"1\":{\"12\":1}}],[\"注意\",{\"1\":{\"49\":1,\"60\":1,\"64\":1,\"69\":1,\"86\":1,\"104\":1,\"106\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"25\":1}}],[\"参数keys的类型必须兼容string|number|symbol\",{\"1\":{\"101\":1}}],[\"参数keys可以是联合类型\",{\"1\":{\"101\":1}}],[\"参数keys用作键名\",{\"1\":{\"101\":1}}],[\"参数type用作键值类型\",{\"1\":{\"101\":1}}],[\"参数type是一个构造函数\",{\"1\":{\"93\":1}}],[\"参数\",{\"1\":{\"96\":2}}],[\"参数变量x可能是字符串\",{\"1\":{\"58\":1}}],[\"参数列表的圆括号后面\",{\"1\":{\"49\":1}}],[\"参数等\",{\"1\":{\"45\":1}}],[\"冒号\",{\"1\":{\"49\":1}}],[\"短期的个人项目\",{\"1\":{\"46\":1}}],[\"虽然可以自己动手做适配\",{\"1\":{\"46\":1}}],[\"过去大部分\",{\"1\":{\"46\":1}}],[\"生态\",{\"1\":{\"46\":1}}],[\"依赖\",{\"1\":{\"46\":1}}],[\"兼容性问题\",{\"1\":{\"46\":1}}],[\"并加上了自己的特征\",{\"1\":{\"81\":1}}],[\"并且那些会修改源数组的方法push\",{\"1\":{\"103\":1}}],[\"并且只在当前代码块有效\",{\"1\":{\"76\":1}}],[\"并且还可以新增其他属性\",{\"1\":{\"44\":1}}],[\"并将其中的this参数删除\",{\"1\":{\"96\":1}}],[\"并将\",{\"1\":{\"46\":1}}],[\"检查类型是否正确\",{\"1\":{\"46\":1}}],[\"引擎提供\",{\"1\":{\"107\":1}}],[\"引擎运行\",{\"1\":{\"46\":1}}],[\"引入了unknown类型\",{\"1\":{\"57\":1}}],[\"引入了独立的编译步骤\",{\"1\":{\"46\":1}}],[\"引入了一个更强大\",{\"1\":{\"44\":1}}],[\"引入这种静态类型特征\",{\"1\":{\"44\":1}}],[\"要获取它的构造方法\",{\"1\":{\"93\":1}}],[\"要退出这个\",{\"1\":{\"52\":1}}],[\"要求开发者付出更高的学习成本\",{\"1\":{\"46\":1}}],[\"要学习的东西更多\",{\"1\":{\"46\":1}}],[\"还是小写的object类型\",{\"1\":{\"69\":1}}],[\"还引入了\",{\"1\":{\"58\":1}}],[\"还有一个很大的问题\",{\"1\":{\"56\":1}}],[\"还需要编写类型声明\",{\"1\":{\"46\":1}}],[\"还不会编写\",{\"1\":{\"10\":1}}],[\"程序员不仅需要编写功能\",{\"1\":{\"46\":1}}],[\"增加了编程工作量\",{\"1\":{\"46\":1}}],[\"动态类型有非常高的灵活性\",{\"1\":{\"46\":1}}],[\"动态类型与静态类型\",{\"0\":{\"44\":1}}],[\"丧失了动态类型的代码灵活性\",{\"1\":{\"46\":1}}],[\"项目\",{\"1\":{\"56\":2}}],[\"项目都没有做\",{\"1\":{\"46\":1}}],[\"项目转成\",{\"1\":{\"45\":1}}],[\"项目越大越痛苦\",{\"1\":{\"45\":1}}],[\"综上所述\",{\"1\":{\"45\":1}}],[\"重构后的代码也能正常运行\",{\"1\":{\"45\":1}}],[\"因为根据thistype<\",{\"1\":{\"106\":1}}],[\"因为helperthisvalue里面没有这个方法\",{\"1\":{\"106\":1}}],[\"因为数组的成员数量是不确定的\",{\"1\":{\"86\":1}}],[\"因为unique\",{\"1\":{\"60\":1}}],[\"因为这是不允许的运算\",{\"1\":{\"57\":1}}],[\"因为没有类型检查\",{\"1\":{\"56\":1}}],[\"因为\",{\"1\":{\"56\":1,\"86\":1}}],[\"因为不确定修改后是否会影响到其他部分的代码\",{\"1\":{\"45\":1}}],[\"因此exclude<t\",{\"1\":{\"91\":1}}],[\"因此symbol和bigint这两个类型虽然存在\",{\"1\":{\"66\":1}}],[\"因此可以借助于\",{\"1\":{\"12\":1}}],[\"因此\",{\"1\":{\"9\":1,\"50\":1,\"58\":1,\"100\":1,\"102\":1}}],[\"往往非常痛苦\",{\"1\":{\"45\":1}}],[\"借助类型信息\",{\"1\":{\"45\":1}}],[\"熟练的开发者往往只看类型\",{\"1\":{\"45\":1}}],[\"解释应该如何使用这些代码\",{\"1\":{\"45\":1}}],[\"只用来跟其他类型组成交叉类型\",{\"1\":{\"106\":1}}],[\"只会让y变成只读\",{\"1\":{\"100\":1}}],[\"只读元组\",{\"0\":{\"84\":1}}],[\"只读写法\",{\"1\":{\"81\":1}}],[\"只读数组赋值给可变数组\",{\"1\":{\"81\":1}}],[\"只读数组没有pop\",{\"1\":{\"81\":1}}],[\"只读数组\",{\"0\":{\"81\":1}}],[\"只希望包含真正的对象\",{\"1\":{\"69\":1}}],[\"只包含对象\",{\"1\":{\"69\":1}}],[\"只能接受两个参数\",{\"1\":{\"86\":1}}],[\"只能写成类型为typeof\",{\"1\":{\"60\":1}}],[\"只能用const命令声明\",{\"1\":{\"60\":1}}],[\"只能进行比较运算\",{\"1\":{\"57\":1}}],[\"只有对象才有方法\",{\"1\":{\"65\":1}}],[\"只有never唯一一个\",{\"1\":{\"58\":1}}],[\"只有明确unknown变量的实际类型\",{\"1\":{\"57\":1}}],[\"只有到运行阶段才会报错\",{\"1\":{\"45\":1}}],[\"只要打开这个选项\",{\"1\":{\"70\":1}}],[\"只要推断出any类型就会报错\",{\"1\":{\"56\":1}}],[\"只要开发者使用了any类型\",{\"1\":{\"56\":1}}],[\"只要句法正确\",{\"1\":{\"56\":1}}],[\"只要函数或对象的参数和返回值保持类型不变\",{\"1\":{\"45\":1}}],[\"只键入一部分的变量名或函数名\",{\"1\":{\"45\":1}}],[\"一种写法是使用as\",{\"1\":{\"86\":1}}],[\"一种用在值相关的\",{\"1\":{\"75\":1}}],[\"一章\",{\"1\":{\"58\":1}}],[\"一定要显式声明类型\",{\"1\":{\"56\":1}}],[\"一律为在标识符后面添加\",{\"1\":{\"49\":1}}],[\"一般来说\",{\"1\":{\"45\":1,\"57\":1}}],[\"一般都会利用类型信息\",{\"1\":{\"45\":1}}],[\"一旦确定某个值的类型\",{\"1\":{\"43\":1}}],[\"比如\",{\"1\":{\"45\":1,\"60\":1}}],[\"比如数值123和字符串hello\",{\"1\":{\"44\":1}}],[\"集成开发环境\",{\"1\":{\"45\":1}}],[\"做到语法提示和自动补全\",{\"1\":{\"45\":1}}],[\"支持块级类型声明\",{\"1\":{\"76\":1}}],[\"支持\",{\"1\":{\"45\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"20\":1}}],[\"方法和\",{\"1\":{\"89\":1}}],[\"方法是在数组类型前面加上readonly关键字\",{\"1\":{\"81\":1}}],[\"方法其实是定义在包装对象上\",{\"1\":{\"65\":1}}],[\"方法会返回相同的\",{\"1\":{\"60\":1}}],[\"方法\",{\"1\":{\"45\":1,\"65\":1}}],[\"发现字符串没有find\",{\"1\":{\"45\":1}}],[\"发现类型不对\",{\"1\":{\"43\":1}}],[\"返回剩下的属性\",{\"1\":{\"95\":1}}],[\"返回值取决于泛型类型\",{\"1\":{\"104\":1}}],[\"返回值是该构造函数的实例类型\",{\"1\":{\"93\":1}}],[\"返回值的类型就可以写成never\",{\"1\":{\"58\":1}}],[\"返回一个字符串\",{\"1\":{\"75\":1}}],[\"返回的是一个字符串\",{\"1\":{\"45\":1}}],[\"返回顶部按钮\",{\"1\":{\"3\":1,\"6\":1}}],[\"提取指定类型union\",{\"1\":{\"92\":1}}],[\"提示\",{\"1\":{\"66\":1,\"70\":1,\"71\":1,\"72\":1,\"75\":1,\"81\":1,\"83\":1,\"100\":1,\"102\":1}}],[\"提示运算符+不能用于数值和布尔值的相加\",{\"1\":{\"45\":1}}],[\"提供了一个编译选项strictnullchecks\",{\"1\":{\"70\":1}}],[\"提供了一个编译选项noimplicitany\",{\"1\":{\"56\":1}}],[\"提供了代码文档\",{\"1\":{\"45\":1}}],[\"提供语法提示功能\",{\"1\":{\"45\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"14\":1}}],[\"写法二\",{\"1\":{\"84\":1}}],[\"写法一\",{\"1\":{\"84\":1}}],[\"写成messege\",{\"1\":{\"45\":1}}],[\"写作日期为\",{\"1\":{\"27\":1}}],[\"节省程序员的时间\",{\"1\":{\"45\":1}}],[\"节流\",{\"1\":{\"37\":1}}],[\"大多数时候\",{\"1\":{\"69\":1}}],[\"大写的object类型代表\",{\"1\":{\"68\":1}}],[\"大大降低了线上风险\",{\"1\":{\"45\":1}}],[\"大家可能知道\",{\"1\":{\"44\":1}}],[\"避免交付有问题的代码\",{\"1\":{\"45\":1}}],[\"避免使用时报错\",{\"1\":{\"43\":1}}],[\"有两种写法\",{\"1\":{\"84\":1}}],[\"有两个\",{\"1\":{\"58\":1}}],[\"有些年代很久的大型\",{\"1\":{\"56\":1}}],[\"有时会显著拖长项目的开发时间\",{\"1\":{\"46\":1}}],[\"有了类型之后\",{\"1\":{\"46\":1}}],[\"有了静态类型\",{\"1\":{\"45\":1}}],[\"有助于提高代码质量\",{\"1\":{\"45\":1}}],[\"有助于代码重构\",{\"1\":{\"45\":1}}],[\"有利于发现错误\",{\"1\":{\"45\":1}}],[\"有利于代码的静态分析\",{\"1\":{\"45\":1}}],[\"有一个属性foo\",{\"1\":{\"44\":1}}],[\"有一个参数n\",{\"1\":{\"43\":1}}],[\"想要达到的目的\",{\"1\":{\"45\":1}}],[\"即实例类型\",{\"1\":{\"93\":1}}],[\"即元组长度\",{\"1\":{\"85\":1}}],[\"即数组的各个成员的类型可以不同\",{\"1\":{\"83\":1}}],[\"即不允许变动数组成员\",{\"1\":{\"81\":1}}],[\"即不可能返回任何值\",{\"1\":{\"58\":1}}],[\"即不可能有这样的值\",{\"1\":{\"58\":1}}],[\"即类型可以声明在代码块\",{\"1\":{\"76\":1}}],[\"即跟类型相关的代码之中\",{\"1\":{\"75\":1}}],[\"即别名允许嵌套\",{\"1\":{\"74\":1}}],[\"即交叉类型同时满足a和b的特征\",{\"1\":{\"73\":1}}],[\"即可以用字面量表示的对象\",{\"1\":{\"69\":1}}],[\"即symbol\",{\"1\":{\"65\":1}}],[\"即联合类型\",{\"1\":{\"58\":1}}],[\"即该类型为空\",{\"1\":{\"58\":1}}],[\"即将一个不确定的类型缩小为更明确的类型\",{\"1\":{\"57\":1}}],[\"即使打开了noimplicitany\",{\"1\":{\"56\":1}}],[\"即使有明显的类型错误\",{\"1\":{\"56\":1}}],[\"即变量的类型是静态的\",{\"1\":{\"44\":1}}],[\"即它继承了后者的全部语法\",{\"1\":{\"42\":1}}],[\"已经推断确定了类型\",{\"1\":{\"44\":1}}],[\"属于静态类型语言\",{\"1\":{\"44\":1}}],[\"属于动态类型语言\",{\"1\":{\"44\":1}}],[\"更高的学习成本\",{\"1\":{\"46\":1}}],[\"更适合用在大型的企业级项目\",{\"1\":{\"45\":1}}],[\"更好的\",{\"1\":{\"45\":1}}],[\"更严格的类型系统\",{\"1\":{\"44\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"6\":1}}],[\"更新时间\",{\"1\":{\"3\":1}}],[\"非常不利\",{\"1\":{\"44\":1}}],[\"也就是返回type的非空类型版本\",{\"1\":{\"94\":1}}],[\"也就是说\",{\"1\":{\"44\":1,\"75\":1,\"83\":1}}],[\"也不利于发挥类型系统的优势\",{\"1\":{\"70\":1}}],[\"也不会报错\",{\"1\":{\"56\":1}}],[\"也可能是数值\",{\"1\":{\"58\":1}}],[\"也可以当作元组\",{\"1\":{\"86\":1}}],[\"也可以是零成员\",{\"1\":{\"79\":1}}],[\"也可以在定义一个别名时\",{\"1\":{\"74\":1}}],[\"也可以通过\",{\"1\":{\"52\":1}}],[\"也可以推断函数的返回值\",{\"1\":{\"50\":1}}],[\"也属于\",{\"1\":{\"57\":1}}],[\"也检查不出错误\",{\"1\":{\"56\":1}}],[\"也没有指定类型\",{\"1\":{\"56\":1}}],[\"也是这样来声明类型\",{\"1\":{\"49\":1}}],[\"也是动态的\",{\"1\":{\"44\":1}}],[\"变量helperfunctions的this应该满足helperthisvalue的条件\",{\"1\":{\"106\":1}}],[\"变量helperfunctions的类型是一个正常的对象类型与thistype<helperthisvalue>组成的交叉类型\",{\"1\":{\"106\":1}}],[\"变量values的类型是一个只读数组\",{\"1\":{\"103\":1}}],[\"变量v是unknown类型\",{\"1\":{\"57\":1}}],[\"变量如果等于undefined就表示还没有赋值\",{\"1\":{\"70\":1}}],[\"变量a和b都是字符串\",{\"1\":{\"60\":1}}],[\"变量a和变量b的类型虽然都是unique\",{\"1\":{\"60\":1}}],[\"变量类型默认就是unique\",{\"1\":{\"60\":1}}],[\"变量类型一旦设为any\",{\"1\":{\"56\":1}}],[\"变量y当作属性名\",{\"1\":{\"60\":1}}],[\"变量y继续进行各种数值运算\",{\"1\":{\"56\":1}}],[\"变量y的类型是number\",{\"1\":{\"56\":1}}],[\"变量y是一个对象\",{\"1\":{\"44\":1}}],[\"变量x同时是数值和字符串\",{\"1\":{\"73\":1}}],[\"变量x和y声明时没有赋值\",{\"1\":{\"56\":1}}],[\"变量x的类型是never\",{\"1\":{\"58\":1}}],[\"变量x的类型是unknown\",{\"1\":{\"57\":1}}],[\"变量x的类型是any\",{\"1\":{\"56\":2}}],[\"变量x的类型推断为any\",{\"1\":{\"56\":1}}],[\"变量x的值是一个字符串\",{\"1\":{\"56\":1}}],[\"变量x声明时\",{\"1\":{\"44\":1}}],[\"变量foo并没有类型声明\",{\"1\":{\"50\":1}}],[\"变量foo的后面使用冒号\",{\"1\":{\"49\":1}}],[\"变量的值应该与声明的类型一致\",{\"1\":{\"49\":1}}],[\"变量的类型是动态的\",{\"1\":{\"44\":1}}],[\"变量加上了类型声明\",{\"1\":{\"49\":1}}],[\"例变量b的类型\",{\"1\":{\"60\":1}}],[\"例二的报错是因为对象的属性也是静态的\",{\"1\":{\"44\":1}}],[\"例二let\",{\"1\":{\"44\":2}}],[\"例一的报错是因为变量赋值时\",{\"1\":{\"44\":1}}],[\"例一let\",{\"1\":{\"44\":2}}],[\"x1\",{\"1\":{\"71\":2}}],[\"x就是never类型了\",{\"1\":{\"58\":1}}],[\"x\",{\"1\":{\"44\":4,\"52\":3,\"56\":16,\"57\":4,\"58\":5,\"59\":2,\"60\":5,\"61\":6,\"70\":1,\"71\":9,\"72\":3,\"73\":1,\"75\":3,\"83\":2,\"86\":2,\"90\":4,\"93\":1,\"95\":6,\"97\":2,\"98\":2,\"99\":6,\"100\":2,\"102\":2,\"103\":2,\"106\":3}}],[\"在集合论上\",{\"1\":{\"57\":1}}],[\"在于所有类型的值都可以分配给unknown类型\",{\"1\":{\"57\":1}}],[\"在\",{\"1\":{\"52\":1,\"59\":1,\"65\":1}}],[\"在语法上\",{\"1\":{\"44\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"3\":1}}],[\"而this\",{\"1\":{\"106\":1}}],[\"而null和undefined不属于object\",{\"1\":{\"94\":1}}],[\"而有所不同\",{\"1\":{\"80\":1}}],[\"而date\",{\"1\":{\"75\":1}}],[\"而是该值的\",{\"1\":{\"75\":1}}],[\"而是增强\",{\"1\":{\"42\":1}}],[\"而且都是字符串\",{\"1\":{\"75\":1}}],[\"而且\",{\"1\":{\"60\":1}}],[\"而且没有使用限制\",{\"1\":{\"44\":1}}],[\"添加类型系统以后\",{\"1\":{\"46\":1}}],[\"添加类型系统\",{\"1\":{\"44\":1}}],[\"添加的最主要部分\",{\"1\":{\"42\":1}}],[\"前面的partial<type>的定义也可以写成下面这样\",{\"1\":{\"102\":1}}],[\"前面说了\",{\"1\":{\"44\":1}}],[\"前端存储\",{\"0\":{\"34\":1}}],[\"具有提示作用\",{\"1\":{\"43\":1}}],[\"函数生成\",{\"1\":{\"59\":1}}],[\"函数f\",{\"1\":{\"58\":1}}],[\"函数\",{\"1\":{\"58\":1}}],[\"函数add\",{\"1\":{\"56\":1}}],[\"函数addone\",{\"1\":{\"43\":2}}],[\"函数tostring\",{\"1\":{\"49\":1}}],[\"函数参数和返回值\",{\"1\":{\"49\":1}}],[\"函数定义里面加入类型\",{\"1\":{\"43\":1}}],[\"作为一个新类型返回\",{\"1\":{\"104\":1}}],[\"作为类型\",{\"1\":{\"93\":1}}],[\"作为比较\",{\"1\":{\"43\":1}}],[\"作者设置为\",{\"1\":{\"27\":1}}],[\"开发阶段很可能发现不了这个问题\",{\"1\":{\"43\":1}}],[\"传入了一个字符串hello\",{\"1\":{\"43\":1}}],[\"传入其他类型的值就会报错\",{\"1\":{\"43\":1}}],[\"报错type\",{\"1\":{\"90\":1}}],[\"报错delete\",{\"1\":{\"81\":1}}],[\"报错let\",{\"1\":{\"57\":3}}],[\"报错\",{\"1\":{\"43\":1,\"44\":3,\"45\":3,\"56\":1,\"57\":3,\"60\":6,\"66\":1,\"68\":2,\"69\":3,\"70\":4,\"71\":3,\"74\":1,\"75\":2,\"80\":1,\"81\":5,\"83\":1,\"85\":1,\"86\":1,\"90\":1,\"93\":2,\"97\":2,\"99\":1,\"100\":1,\"103\":4,\"104\":2,\"106\":2}}],[\"下面是另一个例子\",{\"1\":{\"57\":1,\"106\":1}}],[\"下面是一段简单的\",{\"1\":{\"43\":1}}],[\"下一篇\",{\"1\":{\"3\":1}}],[\"减少错误\",{\"1\":{\"43\":1}}],[\"帮助提高代码质量\",{\"1\":{\"43\":1}}],[\"凡是需要设为any类型的地方\",{\"1\":{\"57\":1}}],[\"凡是不适用该类型的地方\",{\"1\":{\"43\":1}}],[\"凡是适用该类型的地方\",{\"1\":{\"43\":1}}],[\"这四个工具类型都定义在\",{\"1\":{\"107\":1}}],[\"这里的thistype的作用是提示\",{\"1\":{\"106\":1}}],[\"这里有一个特殊情况\",{\"1\":{\"56\":1}}],[\"这一点需要注意\",{\"1\":{\"97\":1}}],[\"这是一个只读的值类型\",{\"1\":{\"86\":1}}],[\"这是为了保证这个属性是固定不变的\",{\"1\":{\"60\":1}}],[\"这导致如果函数调用时\",{\"1\":{\"86\":1}}],[\"这种用法的typeof返回的是\",{\"1\":{\"75\":1}}],[\"这意味着\",{\"1\":{\"74\":1}}],[\"这意味着你可以在\",{\"1\":{\"29\":1}}],[\"这当然是不可能的\",{\"1\":{\"73\":1}}],[\"这并不是开发者想要的行为\",{\"1\":{\"70\":1}}],[\"这囊括了几乎所有的值\",{\"1\":{\"68\":1}}],[\"这两个函数不能当作构造函数使用\",{\"1\":{\"66\":1}}],[\"这行代码之所以可以运行\",{\"1\":{\"65\":1}}],[\"这可以保证不会跟其他属性名冲突\",{\"1\":{\"60\":1}}],[\"这也跟集合论有关\",{\"1\":{\"58\":1}}],[\"这也是它的值类型\",{\"1\":{\"60\":1}}],[\"这也是\",{\"1\":{\"45\":1}}],[\"这与any的行为一致\",{\"1\":{\"57\":1}}],[\"这时会依次展开为多个键\",{\"1\":{\"101\":1}}],[\"这时就可以通过parameters<t>和returntype<t>拿到这两个接口类型\",{\"1\":{\"97\":1}}],[\"这时static和readonly两个限定符缺一不可\",{\"1\":{\"60\":1}}],[\"这时\",{\"1\":{\"58\":1,\"72\":1,\"80\":1,\"86\":1}}],[\"这时并不会报错\",{\"1\":{\"56\":1}}],[\"这时即使打开了noimplicitany\",{\"1\":{\"56\":1}}],[\"这时上面的函数add\",{\"1\":{\"56\":1}}],[\"这时你为那些类型复杂的变量加上any\",{\"1\":{\"56\":1}}],[\"这显然是很糟糕的情况\",{\"1\":{\"56\":1}}],[\"这些缺点使得\",{\"1\":{\"46\":1}}],[\"这样设计的目的是\",{\"1\":{\"57\":1}}],[\"这样才能运行\",{\"1\":{\"46\":1}}],[\"这样有利于提早发现错误\",{\"1\":{\"43\":1}}],[\"这增加了不少工作量\",{\"1\":{\"46\":1}}],[\"这就避免了污染问题\",{\"1\":{\"57\":1}}],[\"这就是不宜使用any类型的另一个主要原因\",{\"1\":{\"56\":1}}],[\"这就是\",{\"1\":{\"52\":1,\"57\":1}}],[\"这就是为什么大量\",{\"1\":{\"45\":1}}],[\"这就叫做代码的静态分析\",{\"1\":{\"45\":1}}],[\"这对于大型项目非常重要\",{\"1\":{\"45\":1}}],[\"这对于提前发现代码错误\",{\"1\":{\"44\":1}}],[\"这个对象的this不包含属性y\",{\"1\":{\"106\":1}}],[\"这个成员名是说明性的\",{\"1\":{\"83\":1}}],[\"这个例子里面的圆括号是必须的\",{\"1\":{\"79\":1}}],[\"这个属性还在不在\",{\"1\":{\"44\":1}}],[\"这个值具有该类型的所有特征\",{\"1\":{\"43\":1}}],[\"这个类型\",{\"1\":{\"43\":1}}],[\"所谓\",{\"1\":{\"57\":1,\"65\":1}}],[\"所以修改成员会报错\",{\"1\":{\"103\":1}}],[\"所以就原样返回了\",{\"1\":{\"95\":1}}],[\"所以就不对any类型进行任何限制\",{\"1\":{\"56\":1}}],[\"所以会返回自身\",{\"1\":{\"94\":1}}],[\"所以大多数情况下\",{\"1\":{\"83\":1}}],[\"所以报错\",{\"1\":{\"81\":1}}],[\"所以报错了\",{\"1\":{\"45\":1,\"71\":1,\"99\":1}}],[\"所以子类型number\",{\"1\":{\"81\":1}}],[\"所以读取成员类型也可以写成下面这样\",{\"1\":{\"79\":1}}],[\"所以只能用在类型运算之中\",{\"1\":{\"75\":1}}],[\"所以使用object时常常用空对象代替\",{\"1\":{\"68\":1}}],[\"所以没有办法直接获得\",{\"1\":{\"66\":1}}],[\"所以可以将前者赋值给后者\",{\"1\":{\"60\":1}}],[\"所以可能出现多个\",{\"1\":{\"60\":1}}],[\"所以最后一行就报错了\",{\"1\":{\"60\":1}}],[\"所以类型可以省略不写\",{\"1\":{\"60\":1}}],[\"所以这个类型的变量是不能修改值的\",{\"1\":{\"60\":1}}],[\"所以写不ss出只包含单个\",{\"1\":{\"60\":1}}],[\"所以返回值类型可以写成never\",{\"1\":{\"58\":1}}],[\"所以该类型被称为never\",{\"1\":{\"58\":1}}],[\"所以它和any一样\",{\"1\":{\"57\":1}}],[\"所以它不存在类型推断为any的问题\",{\"1\":{\"56\":1}}],[\"所以对于那些类型不明显的变量\",{\"1\":{\"56\":1}}],[\"所以\",{\"1\":{\"44\":3,\"69\":1,\"70\":1,\"73\":1,\"106\":1}}],[\"所以都属于\",{\"1\":{\"43\":1}}],[\"所有可选成员必须在必选成员之后\",{\"1\":{\"83\":1}}],[\"所有可以转成对象的值\",{\"1\":{\"68\":1}}],[\"所有成员的类型必须相同\",{\"1\":{\"79\":1}}],[\"所有\",{\"1\":{\"42\":1}}],[\"共同特征是都能进行数值运算\",{\"1\":{\"43\":1}}],[\"举例来说\",{\"1\":{\"43\":1}}],[\"它与partial<type>的作用正好相反\",{\"1\":{\"102\":1}}],[\"它与exclude<t\",{\"1\":{\"92\":1}}],[\"它与any含义相同\",{\"1\":{\"57\":1}}],[\"它跟其他类型组成联合类型时\",{\"1\":{\"91\":1}}],[\"它可以返回一些内置构造方法的参数类型\",{\"1\":{\"90\":1}}],[\"它可以赋值给其他任何类型的变量\",{\"1\":{\"56\":1}}],[\"它表示成员类型可以自由设置的数组\",{\"1\":{\"83\":1}}],[\"它表示单个的\",{\"1\":{\"60\":1}}],[\"它的后面只能是一个数组或元组\",{\"1\":{\"83\":1}}],[\"它的操作数依然是一个值\",{\"1\":{\"75\":1}}],[\"它的目的并不是创造一种全新语言\",{\"1\":{\"42\":1}}],[\"它们的实现都是在底层调用\",{\"1\":{\"107\":1}}],[\"它们的值都是不一样的\",{\"1\":{\"60\":1}}],[\"它们没有使用场景\",{\"1\":{\"66\":1}}],[\"它们都是字符串\",{\"1\":{\"66\":1}}],[\"它们属于同一种类型\",{\"1\":{\"43\":1}}],[\"它类似字符串\",{\"1\":{\"59\":1}}],[\"它不能直接使用\",{\"1\":{\"57\":1}}],[\"它会提供一个\",{\"1\":{\"52\":1}}],[\"就表明键值是联合类型\",{\"1\":{\"101\":1}}],[\"就表示开发者想要自己来处理这些代码\",{\"1\":{\"56\":1}}],[\"就属于联合类型a|b\",{\"1\":{\"72\":1}}],[\"就允许了任何类型的变量都可以赋值为这两个值\",{\"1\":{\"70\":1}}],[\"就用5这个字面量来表示\",{\"1\":{\"60\":1}}],[\"就相应规定\",{\"1\":{\"58\":1}}],[\"就不能把一个赋值给另一个\",{\"1\":{\"60\":1}}],[\"就不可能赋给它任何值\",{\"1\":{\"58\":1}}],[\"就不会报错\",{\"1\":{\"57\":1}}],[\"就一定要显式声明类型\",{\"1\":{\"56\":1}}],[\"就多出了一个单独的编译步骤\",{\"1\":{\"46\":1}}],[\"就完全可以放心重构\",{\"1\":{\"45\":1}}],[\"就能用于加法运算了\",{\"1\":{\"57\":1}}],[\"就能基本确定\",{\"1\":{\"45\":1}}],[\"就能大致推断代码的作用\",{\"1\":{\"45\":1}}],[\"就能轻松发现拼写错误\",{\"1\":{\"45\":1}}],[\"就会返回unknown\",{\"1\":{\"104\":1}}],[\"就会推断数组成员的类型\",{\"1\":{\"80\":1}}],[\"就会推断该变量是值类型\",{\"1\":{\"71\":1}}],[\"就会推断它的类型\",{\"1\":{\"50\":1}}],[\"就会认为这两个变量和函数返回值的类型都是any\",{\"1\":{\"56\":1}}],[\"就会认为该变量的类型是any\",{\"1\":{\"56\":1}}],[\"就会得到结果\",{\"1\":{\"52\":1}}],[\"就会直接报错\",{\"1\":{\"45\":1}}],[\"就会报错\",{\"1\":{\"45\":1,\"49\":1,\"50\":1,\"56\":1,\"90\":1,\"93\":1}}],[\"就可以采用联合类型的写法\",{\"1\":{\"72\":1}}],[\"就可以把该变量的类型设为any\",{\"1\":{\"56\":1}}],[\"就可以被赋值为任意类型的值\",{\"1\":{\"56\":1}}],[\"就可以直接运行\",{\"1\":{\"52\":1}}],[\"就可以发现很多问题\",{\"1\":{\"45\":1}}],[\"就可以确定变量的类型\",{\"1\":{\"45\":1}}],[\"就可以说\",{\"1\":{\"43\":1}}],[\"就是因为在调用方法时\",{\"1\":{\"65\":1}}],[\"就是用作属性名\",{\"1\":{\"60\":1}}],[\"就是缩小unknown变量的类型范围\",{\"1\":{\"57\":1}}],[\"就是它会\",{\"1\":{\"56\":1}}],[\"就是使用官网的在线编译页面\",{\"1\":{\"51\":1}}],[\"就是为\",{\"1\":{\"44\":1,\"49\":1}}],[\"就是一个独立的类型系统\",{\"1\":{\"42\":1}}],[\"就报错了\",{\"1\":{\"43\":1}}],[\"就意味着\",{\"1\":{\"43\":1}}],[\"指定的键名keys必须是对象键名type里面已经存在的键名\",{\"1\":{\"99\":1}}],[\"指定删除的键名keys可以是对象类型type中不存在的属性\",{\"1\":{\"95\":1}}],[\"指的多个类型组成的一个新类型\",{\"1\":{\"73\":1}}],[\"指的是多个类型组成的一个新类型\",{\"1\":{\"72\":1}}],[\"指的是这些值在需要时\",{\"1\":{\"65\":1}}],[\"指的是一组具有相同特征的值\",{\"1\":{\"43\":1}}],[\"指出没有定义过这个属性\",{\"1\":{\"45\":1}}],[\"指出这个位置只能传入数值\",{\"1\":{\"43\":1}}],[\"指南\",{\"2\":{\"7\":1}}],[\"脚本script\",{\"1\":{\"52\":1}}],[\"脚本\",{\"1\":{\"42\":1,\"52\":2}}],[\"脚本都可以当作\",{\"1\":{\"42\":1}}],[\"脚注\",{\"0\":{\"16\":1}}],[\"使其变成必选属性\",{\"1\":{\"102\":1}}],[\"使其更适合多人合作的企业级项目\",{\"1\":{\"42\":1}}],[\"使用这个类型工具时\",{\"1\":{\"106\":1}}],[\"使用这个值都会报错\",{\"1\":{\"43\":1}}],[\"使用扩展运算符传入函数参数\",{\"1\":{\"86\":1}}],[\"使用扩展运算符\",{\"1\":{\"83\":1}}],[\"使用t\",{\"1\":{\"82\":1}}],[\"使用另一个别名\",{\"1\":{\"74\":1}}],[\"使用符号\",{\"1\":{\"73\":1}}],[\"使用符号|表示\",{\"1\":{\"72\":1}}],[\"使用let和var命令声明变量\",{\"1\":{\"56\":1}}],[\"使用时\",{\"1\":{\"52\":1}}],[\"使用方法\",{\"1\":{\"51\":1}}],[\"使用\",{\"0\":{\"36\":1}}],[\"使用指南\",{\"1\":{\"27\":2},\"2\":{\"2\":1,\"4\":1,\"23\":1,\"30\":1,\"31\":1}}],[\"语义错误和方法调用错误\",{\"1\":{\"45\":1}}],[\"语言里面的广义对象\",{\"1\":{\"68\":1}}],[\"语言中\",{\"1\":{\"65\":1}}],[\"语言\",{\"1\":{\"64\":1}}],[\"语言规定const声明变量时\",{\"1\":{\"56\":1}}],[\"语言本身就有一套自己的类型系统\",{\"1\":{\"44\":1}}],[\"语言就没有这个功能\",{\"1\":{\"43\":1}}],[\"语言的编程语言\",{\"1\":{\"42\":1}}],[\"语法\",{\"0\":{\"18\":1},\"1\":{\"14\":1,\"29\":1}}],[\"语法进行了扩展\",{\"1\":{\"13\":1}}],[\"语法扩展\",{\"1\":{\"12\":1}}],[\"java\",{\"0\":{\"116\":1}}],[\"javascript\",{\"1\":{\"42\":5,\"43\":1,\"44\":7,\"45\":5,\"46\":5,\"49\":1,\"56\":3,\"64\":2,\"65\":2,\"68\":1,\"69\":2,\"70\":1,\"75\":2,\"83\":1,\"107\":2},\"2\":{\"38\":1,\"114\":1}}],[\"john\",{\"1\":{\"72\":1}}],[\"json\",{\"1\":{\"70\":1}}],[\"js\",{\"1\":{\"42\":1}}],[\"简称\",{\"1\":{\"42\":2}}],[\"概述\",{\"0\":{\"42\":1}}],[\"<t\",{\"1\":{\"104\":1}}],[\"<\",{\"1\":{\"37\":1,\"74\":1}}],[\"d\",{\"1\":{\"52\":1,\"92\":1,\"107\":1}}],[\"delete\",{\"1\":{\"44\":2}}],[\"delay\",{\"1\":{\"37\":5}}],[\"debounce\",{\"1\":{\"37\":1}}],[\"database\",{\"1\":{\"36\":1}}],[\"dataview\",{\"1\":{\"35\":1}}],[\"date\",{\"1\":{\"35\":1,\"37\":1,\"75\":1}}],[\"手写防抖和节流\",{\"0\":{\"37\":1}}],[\"null>\",{\"1\":{\"94\":1}}],[\"null\",{\"0\":{\"70\":1},\"1\":{\"64\":1,\"68\":1,\"70\":4,\"72\":2,\"91\":2,\"92\":1,\"94\":1}}],[\"num\",{\"1\":{\"49\":2,\"50\":2}}],[\"number|string\",{\"1\":{\"101\":1}}],[\"number>\",{\"1\":{\"97\":1,\"101\":2}}],[\"number是5的父类型\",{\"1\":{\"71\":1}}],[\"numbers\",{\"1\":{\"64\":3,\"66\":1,\"67\":1}}],[\"number\",{\"1\":{\"43\":3,\"49\":1,\"50\":1,\"56\":1,\"57\":2,\"58\":3,\"64\":1,\"65\":2,\"66\":2,\"68\":1,\"69\":1,\"70\":2,\"71\":2,\"72\":1,\"73\":3,\"74\":1,\"75\":5,\"76\":1,\"79\":3,\"80\":2,\"81\":6,\"82\":1,\"83\":11,\"84\":2,\"85\":2,\"86\":6,\"89\":2,\"90\":2,\"91\":1,\"92\":1,\"94\":2,\"95\":8,\"96\":1,\"97\":6,\"98\":4,\"99\":8,\"100\":5,\"101\":5,\"102\":4,\"103\":2,\"104\":5,\"105\":2,\"106\":3}}],[\"new\",{\"1\":{\"58\":1,\"66\":2,\"90\":2,\"93\":2}}],[\"never类型是任何其他类型所共有的\",{\"1\":{\"58\":1}}],[\"never类型\",{\"1\":{\"58\":1}}],[\"never类型的一个重要特点是\",{\"1\":{\"58\":1}}],[\"never类型的使用场景\",{\"1\":{\"58\":1}}],[\"never\",{\"0\":{\"58\":1},\"1\":{\"58\":3,\"90\":2,\"91\":1,\"92\":2,\"93\":1,\"94\":1,\"97\":2,\"104\":1,\"105\":1}}],[\"npx会在线调用\",{\"1\":{\"52\":1}}],[\"npx\",{\"1\":{\"52\":2}}],[\"npm\",{\"1\":{\"52\":2}}],[\"not\",{\"1\":{\"115\":1}}],[\"nonnullable<t>\",{\"1\":{\"94\":1}}],[\"nonnullable<type>的实现如下\",{\"1\":{\"94\":1}}],[\"nonnullable<type>用来从联合类型type删除null类型和undefined类型\",{\"1\":{\"94\":1}}],[\"nonnullable<null\",{\"1\":{\"94\":1}}],[\"nonnullable<number\",{\"1\":{\"94\":1}}],[\"nonnullable<boolean>\",{\"1\":{\"94\":1}}],[\"nonnullable<string\",{\"1\":{\"94\":3}}],[\"no\",{\"1\":{\"64\":3,\"66\":1,\"67\":1}}],[\"noimplicitany\",{\"1\":{\"56\":1}}],[\"node命令\",{\"1\":{\"52\":1}}],[\"node\",{\"0\":{\"52\":1},\"1\":{\"52\":10}}],[\"now\",{\"1\":{\"36\":1,\"37\":1}}],[\"n\",{\"1\":{\"43\":2,\"57\":2,\"103\":1}}],[\"namednums\",{\"1\":{\"83\":3}}],[\"names\",{\"1\":{\"79\":4}}],[\"namehere\",{\"1\":{\"36\":1}}],[\"name\",{\"1\":{\"36\":2,\"72\":3,\"79\":2,\"97\":2,\"100\":3,\"106\":1}}],[\"export\",{\"1\":{\"97\":1}}],[\"extract<t\",{\"1\":{\"92\":1}}],[\"extract<200\",{\"1\":{\"92\":1}}],[\"extract<string\",{\"1\":{\"92\":2}}],[\"extract<\",{\"1\":{\"92\":4}}],[\"extract<uniontype\",{\"1\":{\"92\":2}}],[\"extends\",{\"1\":{\"90\":2,\"91\":1,\"92\":1,\"93\":2,\"95\":1,\"96\":2,\"97\":2,\"99\":1,\"101\":1,\"104\":4,\"105\":1}}],[\"excludedmembers>的实现如下\",{\"1\":{\"91\":1}}],[\"excludedmembers>用来从联合类型uniontype里面\",{\"1\":{\"91\":1}}],[\"exclude<keyof\",{\"1\":{\"95\":1}}],[\"exclude<t\",{\"1\":{\"91\":1}}],[\"exclude<number\",{\"1\":{\"91\":1}}],[\"exclude<200\",{\"1\":{\"91\":1}}],[\"exclude<string\",{\"1\":{\"91\":2}}],[\"exclude<\",{\"1\":{\"91\":3}}],[\"exclude<uniontype\",{\"1\":{\"91\":2}}],[\"exit\",{\"1\":{\"52\":1}}],[\"e\",{\"1\":{\"65\":1}}],[\"else\",{\"1\":{\"37\":1,\"58\":2,\"76\":1}}],[\"empty\",{\"1\":{\"36\":1}}],[\"err\",{\"1\":{\"36\":8}}],[\"error\",{\"1\":{\"35\":2,\"58\":2,\"93\":1,\"106\":2}}],[\"0\",{\"1\":{\"36\":1,\"37\":1,\"45\":1,\"57\":2,\"74\":1,\"75\":1,\"79\":1,\"81\":7,\"93\":2,\"97\":1,\"103\":1}}],[\"如果类型不是函数\",{\"1\":{\"104\":1}}],[\"如果类型参数是any或never两个特殊值\",{\"1\":{\"93\":1}}],[\"如果类型参数不是构造方法\",{\"1\":{\"93\":1}}],[\"如果泛型不带有限制条件\",{\"1\":{\"104\":1}}],[\"如果参数type是联合类型\",{\"1\":{\"101\":1}}],[\"如果参数类型是泛型函数\",{\"1\":{\"104\":1}}],[\"如果参数类型type不是带有参数的函数形式\",{\"1\":{\"97\":1}}],[\"如果参数类型union不包含在联合类型uniontype之中\",{\"1\":{\"92\":1}}],[\"如果参数类型不是构造方法\",{\"1\":{\"90\":1}}],[\"如果函数没有this参数\",{\"1\":{\"105\":1}}],[\"如果函数没有\",{\"1\":{\"96\":1}}],[\"如果它的类型参数不是\",{\"1\":{\"89\":1}}],[\"如果初始值不是空数组\",{\"1\":{\"80\":1}}],[\"如果数组变量没有声明类型\",{\"1\":{\"80\":1}}],[\"如果数组成员的类型比较复杂\",{\"1\":{\"79\":1}}],[\"如果某个变量确实可能包含空值\",{\"1\":{\"72\":1}}],[\"如果代码里面没有注明类型\",{\"1\":{\"71\":1}}],[\"如果等于null就表示值为空\",{\"1\":{\"70\":1}}],[\"如果赋值为另一个\",{\"1\":{\"61\":2}}],[\"如果变量的初始值是空数组\",{\"1\":{\"80\":1}}],[\"如果变量声明时没有给出类型\",{\"1\":{\"61\":1}}],[\"如果变量foo更改为其他类型的值\",{\"1\":{\"50\":1}}],[\"如果要把某一个特定的\",{\"1\":{\"60\":1}}],[\"如果要写成与变量a同一个unique\",{\"1\":{\"60\":1}}],[\"如果一个变量可能有多种类型\",{\"1\":{\"58\":1}}],[\"如果无法推断出类型\",{\"1\":{\"56\":1}}],[\"如果只是想简单运行\",{\"1\":{\"52\":1}}],[\"如果执行\",{\"1\":{\"52\":1}}],[\"如果不确定元组成员的类型和数量\",{\"1\":{\"83\":1}}],[\"如果不赋值\",{\"1\":{\"56\":1}}],[\"如果不安装\",{\"1\":{\"52\":1}}],[\"如果不一致\",{\"1\":{\"49\":1}}],[\"如果没有可选成员和扩展运算符\",{\"1\":{\"85\":1}}],[\"如果没有\",{\"1\":{\"50\":1}}],[\"如果还有配套的单元测试\",{\"1\":{\"45\":1}}],[\"如果是的就返回never类型\",{\"1\":{\"91\":1}}],[\"如果是\",{\"1\":{\"45\":1}}],[\"如果两个值具有某种共同的特征\",{\"1\":{\"43\":1}}],[\"如果你是一个新手\",{\"1\":{\"10\":1}}],[\"如下输出\",{\"1\":{\"36\":1}}],[\"不允许修改\",{\"1\":{\"84\":1}}],[\"不允许随意增删\",{\"1\":{\"44\":1}}],[\"不使用大写类型object\",{\"1\":{\"69\":1}}],[\"不希望包含原始类型\",{\"1\":{\"69\":1}}],[\"不包括原始类型的值\",{\"1\":{\"69\":1}}],[\"不包含任何值\",{\"1\":{\"58\":1}}],[\"不可再分的值\",{\"1\":{\"65\":1}}],[\"不可能返回值的函数\",{\"1\":{\"58\":1}}],[\"不是元组\",{\"1\":{\"86\":1}}],[\"不是\",{\"1\":{\"64\":1}}],[\"不是固定不变的值\",{\"1\":{\"60\":1}}],[\"不过我们知道\",{\"1\":{\"60\":1}}],[\"不过使用时难免还是会有一些兼容性问题\",{\"1\":{\"46\":1}}],[\"不同类型的值肯定是不相等的\",{\"1\":{\"60\":1}}],[\"不同于\",{\"1\":{\"36\":1}}],[\"不能用在值运算\",{\"1\":{\"75\":1}}],[\"不能用let声明\",{\"1\":{\"60\":1}}],[\"不能作为构造函数使用\",{\"1\":{\"65\":1}}],[\"不能是\",{\"1\":{\"60\":1}}],[\"不能使用严格相等运算符进行比较\",{\"1\":{\"60\":1}}],[\"不能直接调用unknown类型变量的方法和属性\",{\"1\":{\"57\":1}}],[\"不能直接赋值给其他类型的变量\",{\"1\":{\"57\":1}}],[\"不能传入字符串\",{\"1\":{\"43\":1}}],[\"不像any那样自由\",{\"1\":{\"57\":1}}],[\"不对其进行类型检查\",{\"1\":{\"56\":1}}],[\"不报错上面示例中\",{\"1\":{\"56\":1}}],[\"不报错\",{\"1\":{\"56\":7,\"58\":3}}],[\"不失为一个便捷的方法\",{\"1\":{\"52\":1}}],[\"不一定适合那些小型的\",{\"1\":{\"46\":1}}],[\"不应该将数值a与布尔值b相加\",{\"1\":{\"45\":1}}],[\"不小心把message拼错了\",{\"1\":{\"45\":1}}],[\"不必运行代码\",{\"1\":{\"45\":1}}],[\"不具有很强的约束性\",{\"1\":{\"44\":1}}],[\"不会检查类型对不对\",{\"1\":{\"43\":1}}],[\"不需要序列化\",{\"1\":{\"35\":1}}],[\"当数据库被全部删除后\",{\"1\":{\"36\":1}}],[\"当值被移除后\",{\"1\":{\"36\":1}}],[\"当出错时\",{\"1\":{\"36\":4}}],[\"当离线仓库中的值被载入时\",{\"1\":{\"36\":1}}],[\"ces\",{\"0\":{\"113\":1}}],[\"capitalize<a>\",{\"1\":{\"110\":1}}],[\"capitalize<stringtype>将字符串的第一个字符转为大写\",{\"1\":{\"110\":1}}],[\"catch\",{\"1\":{\"36\":4}}],[\"c>\",{\"1\":{\"93\":1}}],[\"color\",{\"1\":{\"74\":4,\"83\":2}}],[\"compileroptions\",{\"1\":{\"70\":1}}],[\"constructorparameters<\",{\"1\":{\"90\":1}}],[\"constructorparameters<type>的实现如下\",{\"1\":{\"90\":1}}],[\"constructorparameters<type>提取构造方法type的参数类型\",{\"1\":{\"90\":1}}],[\"constructorparameters<never>\",{\"1\":{\"90\":1}}],[\"constructorparameters<new\",{\"1\":{\"90\":2}}],[\"constructorparameters<any>\",{\"1\":{\"90\":1}}],[\"constructorparameters<function>\",{\"1\":{\"90\":1}}],[\"constructorparameters<functionconstructor>\",{\"1\":{\"90\":1}}],[\"constructorparameters<string>\",{\"1\":{\"90\":1}}],[\"constructorparameters<regexpconstructor>\",{\"1\":{\"90\":1}}],[\"constructorparameters<errorconstructor>\",{\"1\":{\"90\":1}}],[\"const断言\",{\"1\":{\"86\":1}}],[\"const命令声明的变量\",{\"1\":{\"61\":2}}],[\"const命令声明的x是不能改变值的\",{\"1\":{\"56\":1}}],[\"const命令为变量赋值\",{\"1\":{\"60\":1}}],[\"const命令没有这个问题\",{\"1\":{\"56\":1}}],[\"const\",{\"0\":{\"81\":1},\"1\":{\"37\":1,\"45\":3,\"52\":1,\"56\":1,\"60\":17,\"61\":3,\"66\":4,\"70\":1,\"71\":4,\"75\":1,\"80\":2,\"81\":6,\"83\":4,\"86\":4,\"100\":1,\"103\":1}}],[\"console\",{\"1\":{\"36\":8,\"45\":1}}],[\"charat\",{\"1\":{\"65\":2}}],[\"class\",{\"1\":{\"60\":2,\"93\":2}}],[\"cleartimeout\",{\"1\":{\"37\":2}}],[\"clear\",{\"1\":{\"36\":1}}],[\"cleared\",{\"1\":{\"36\":1}}],[\"c\",{\"1\":{\"60\":2,\"83\":2,\"89\":1,\"91\":4,\"92\":3,\"93\":3,\"103\":1}}],[\"ctrl\",{\"1\":{\"52\":1}}],[\"currenttime\",{\"1\":{\"37\":4}}],[\"createinstance\",{\"1\":{\"36\":2}}],[\"cdots\",{\"1\":{\"18\":1}}],[\"此外它再增加了一些自己的语法\",{\"1\":{\"42\":1}}],[\"此处代码运行\",{\"1\":{\"36\":7}}],[\"此文字有脚注\",{\"1\":{\"16\":1}}],[\"void>\",{\"1\":{\"97\":2,\"104\":1}}],[\"void\",{\"1\":{\"91\":2,\"92\":2,\"104\":1,\"106\":1}}],[\"v3\",{\"1\":{\"57\":2,\"58\":1}}],[\"v2\",{\"1\":{\"57\":3,\"58\":1}}],[\"v1\",{\"1\":{\"57\":3,\"58\":1}}],[\"v\",{\"1\":{\"57\":3,\"76\":2}}],[\"vscode\",{\"1\":{\"45\":1}}],[\"var\",{\"1\":{\"36\":2,\"56\":1,\"82\":1}}],[\"values\",{\"1\":{\"103\":5}}],[\"value2\",{\"1\":{\"36\":1}}],[\"value\",{\"1\":{\"36\":5,\"65\":1}}],[\"vue3\",{\"0\":{\"39\":1,\"117\":1},\"2\":{\"40\":1}}],[\"vue\",{\"1\":{\"29\":2}}],[\"vuepress\",{\"0\":{\"13\":1},\"1\":{\"9\":2,\"11\":2,\"12\":1,\"13\":2,\"14\":1,\"28\":1}}],[\"庞大的存储量\",{\"1\":{\"35\":1}}],[\"异步存取\",{\"1\":{\"35\":1}}],[\"仅支持部分\",{\"1\":{\"35\":1}}],[\"omitthisparameter<t>\",{\"1\":{\"96\":1}}],[\"omitthisparameter<t>给出了函数tohex\",{\"1\":{\"96\":1}}],[\"omitthisparameter<type>的实现如下\",{\"1\":{\"96\":1}}],[\"omitthisparameter<type>从函数类型中移除\",{\"1\":{\"96\":1}}],[\"omitthisparameter<typeof\",{\"1\":{\"96\":1}}],[\"omit<t\",{\"1\":{\"95\":1}}],[\"omit<type\",{\"1\":{\"95\":3}}],[\"omit<a\",{\"1\":{\"95\":4}}],[\"omega^i\",{\"1\":{\"18\":1}}],[\"omega^r\",{\"1\":{\"18\":1}}],[\"omega\",{\"1\":{\"18\":4}}],[\"obj\",{\"1\":{\"45\":2,\"68\":10,\"69\":7,\"70\":2,\"73\":2,\"106\":2}}],[\"object的交叉类型\",{\"1\":{\"94\":1}}],[\"object>\",{\"1\":{\"90\":2,\"93\":1}}],[\"object属于复合类型\",{\"1\":{\"65\":1}}],[\"object\",{\"0\":{\"67\":2,\"68\":1,\"69\":1},\"1\":{\"35\":1,\"64\":1,\"65\":1,\"66\":2,\"68\":2,\"69\":1,\"70\":1,\"75\":1,\"93\":3}}],[\"othername\",{\"1\":{\"36\":1}}],[\"otherstore\",{\"1\":{\"36\":2}}],[\"blue\",{\"1\":{\"74\":2,\"83\":1}}],[\"b表示\",{\"1\":{\"73\":1}}],[\"bigint\",{\"1\":{\"64\":1,\"65\":2,\"66\":4,\"75\":1}}],[\"bottom\",{\"1\":{\"58\":1}}],[\"boolean>\",{\"1\":{\"91\":1,\"92\":1}}],[\"boolean\",{\"1\":{\"35\":1,\"57\":1,\"58\":1,\"64\":1,\"65\":2,\"66\":2,\"75\":1,\"83\":4,\"89\":1,\"94\":1,\"104\":1}}],[\"b\",{\"1\":{\"45\":2,\"60\":9,\"66\":1,\"73\":2,\"75\":2,\"83\":4,\"89\":1,\"91\":4,\"92\":5,\"93\":1,\"97\":4,\"101\":3,\"103\":1,\"104\":2,\"108\":1,\"109\":1,\"110\":1,\"111\":1}}],[\"bar\",{\"1\":{\"44\":2,\"73\":3}}],[\"be\",{\"1\":{\"26\":1}}],[\"aaa\",{\"0\":{\"119\":1}}],[\"abstract\",{\"1\":{\"90\":2,\"93\":2}}],[\"abcabc\",{\"1\":{\"52\":1}}],[\"abc\",{\"1\":{\"52\":1,\"72\":1,\"80\":2}}],[\"awaited<boolean\",{\"1\":{\"89\":1}}],[\"awaited<promise<promise<number>>>\",{\"1\":{\"89\":1}}],[\"awaited<promise<string>>\",{\"1\":{\"89\":1}}],[\"awaited<type>会返回\",{\"1\":{\"89\":1}}],[\"awaited<type>用来取出\",{\"1\":{\"89\":1}}],[\"await\",{\"1\":{\"89\":1}}],[\"a2\",{\"1\":{\"81\":3}}],[\"a1\",{\"1\":{\"81\":4}}],[\"age\",{\"1\":{\"70\":6,\"74\":3,\"75\":2,\"83\":1,\"100\":1}}],[\"app\",{\"1\":{\"56\":1,\"70\":1}}],[\"apply\",{\"1\":{\"37\":3}}],[\"add\",{\"1\":{\"56\":2,\"86\":4}}],[\"addone\",{\"1\":{\"43\":2}}],[\"any>\",{\"1\":{\"95\":1,\"97\":1}}],[\"any和unknown\",{\"1\":{\"58\":1}}],[\"any\",{\"1\":{\"56\":4,\"80\":1,\"83\":1,\"90\":3,\"91\":1,\"92\":1,\"93\":5,\"97\":2,\"104\":7,\"105\":1}}],[\"any类型和never类型是两个特殊值\",{\"1\":{\"90\":1}}],[\"any类型除了关闭类型检查\",{\"1\":{\"56\":1}}],[\"any类型可以看成是所有其他类型的全集\",{\"1\":{\"56\":1}}],[\"any类型主要适用以下两个场合\",{\"1\":{\"56\":1}}],[\"any类型\",{\"0\":{\"55\":1}}],[\"a\",{\"1\":{\"45\":2,\"57\":6,\"60\":13,\"66\":1,\"68\":2,\"69\":2,\"73\":2,\"75\":7,\"83\":5,\"89\":1,\"91\":4,\"92\":9,\"93\":1,\"95\":2,\"96\":2,\"97\":4,\"98\":1,\"99\":2,\"100\":1,\"101\":7,\"102\":1,\"103\":1,\"104\":2,\"108\":1,\"109\":1,\"110\":1,\"111\":1}}],[\"arg\",{\"1\":{\"97\":2}}],[\"args\",{\"1\":{\"37\":5,\"90\":2,\"93\":2,\"96\":2,\"97\":2,\"104\":2,\"105\":1}}],[\"arr1\",{\"1\":{\"79\":2}}],[\"arr\",{\"1\":{\"79\":2,\"80\":8,\"81\":8,\"86\":6}}],[\"array<number\",{\"1\":{\"79\":1}}],[\"array<number>\",{\"1\":{\"79\":1}}],[\"arraybuffer\",{\"1\":{\"35\":1}}],[\"array\",{\"1\":{\"35\":1,\"36\":1,\"104\":1}}],[\"as\",{\"1\":{\"26\":1,\"81\":1,\"86\":1}}],[\"存取方便\",{\"1\":{\"35\":1}}],[\"存取不方便\",{\"1\":{\"35\":1}}],[\"存入的内容会经过序列化\",{\"1\":{\"35\":1}}],[\"存储量小\",{\"1\":{\"35\":1}}],[\"存在以下比较明显的缺点\",{\"1\":{\"35\":1}}],[\"something\",{\"1\":{\"106\":1}}],[\"somekey\",{\"1\":{\"36\":2}}],[\"splice\",{\"1\":{\"103\":2}}],[\"s4\",{\"1\":{\"66\":1}}],[\"s3\",{\"1\":{\"66\":1}}],[\"s2\",{\"1\":{\"66\":1}}],[\"s1\",{\"1\":{\"66\":1}}],[\"symbol值类型\",{\"1\":{\"60\":1}}],[\"symbol类型也可以用作类\",{\"1\":{\"60\":1}}],[\"symbol类型的变量\",{\"1\":{\"60\":1}}],[\"symbol类型包含所有的\",{\"1\":{\"60\":1}}],[\"symbol表示单个值\",{\"1\":{\"60\":1}}],[\"symbol\",{\"0\":{\"59\":1,\"60\":1},\"1\":{\"59\":7,\"60\":51,\"61\":15,\"64\":1,\"65\":2,\"66\":5,\"75\":2,\"101\":1}}],[\"s\",{\"1\":{\"57\":3,\"81\":1,\"83\":1,\"97\":2,\"104\":1}}],[\"script\",{\"0\":{\"116\":1,\"118\":1},\"1\":{\"52\":2}}],[\"superset\",{\"1\":{\"42\":1}}],[\"sum\",{\"1\":{\"18\":1}}],[\"strictnullchecks\",{\"1\":{\"70\":3}}],[\"string|regexp\",{\"1\":{\"90\":1}}],[\"string|number\",{\"1\":{\"80\":1,\"94\":1}}],[\"string>\",{\"1\":{\"79\":1,\"97\":1,\"101\":1,\"104\":1}}],[\"string\",{\"1\":{\"35\":1,\"49\":3,\"50\":1,\"52\":1,\"57\":1,\"58\":3,\"60\":2,\"64\":1,\"65\":2,\"66\":9,\"71\":2,\"72\":2,\"73\":3,\"75\":1,\"76\":1,\"79\":5,\"83\":9,\"84\":2,\"89\":1,\"90\":7,\"91\":3,\"92\":2,\"94\":2,\"96\":1,\"97\":8,\"100\":1,\"101\":1,\"104\":4,\"106\":2}}],[\"static\",{\"1\":{\"60\":1}}],[\"static属性\",{\"1\":{\"60\":1}}],[\"store\",{\"1\":{\"36\":2}}],[\"storage\",{\"1\":{\"35\":1}}],[\"secretsanta\",{\"1\":{\"97\":3}}],[\"secretname\",{\"1\":{\"97\":4}}],[\"setting\",{\"1\":{\"72\":1}}],[\"settimeout\",{\"1\":{\"37\":2}}],[\"setitem\",{\"1\":{\"36\":3}}],[\"set\",{\"1\":{\"35\":1}}],[\"sessionstorage\",{\"1\":{\"35\":1}}],[\"wrong\",{\"1\":{\"106\":1}}],[\"wrapper\",{\"1\":{\"65\":1}}],[\"worker\",{\"1\":{\"100\":2}}],[\"world\",{\"1\":{\"45\":1,\"57\":1,\"60\":2,\"71\":1,\"73\":1,\"74\":3}}],[\"web\",{\"1\":{\"35\":1}}],[\"webstorage\",{\"1\":{\"35\":1}}],[\"will\",{\"1\":{\"26\":1}}],[\"学习文档\",{\"2\":{\"33\":1}}],[\"个人学习文档\",{\"0\":{\"32\":1}}],[\"每个声明为unique\",{\"1\":{\"60\":1}}],[\"每个运算符都有严格的类型约束\",{\"1\":{\"45\":1}}],[\"每个变量\",{\"1\":{\"45\":1}}],[\"每个\",{\"1\":{\"29\":1}}],[\"pop\",{\"1\":{\"103\":2}}],[\"point\",{\"1\":{\"85\":2}}],[\"person\",{\"1\":{\"100\":1}}],[\"pick<a\",{\"1\":{\"99\":4}}],[\"pick<type\",{\"1\":{\"99\":3}}],[\"pick<t\",{\"1\":{\"95\":1,\"99\":1}}],[\"p\",{\"1\":{\"90\":2,\"97\":2,\"98\":2,\"99\":2,\"100\":6,\"101\":1,\"102\":4}}],[\"promise<number>>\",{\"1\":{\"89\":1}}],[\"promise\",{\"1\":{\"89\":3}}],[\"primitive\",{\"1\":{\"65\":1}}],[\"push\",{\"1\":{\"80\":3,\"81\":2,\"103\":1}}],[\"public\",{\"1\":{\"28\":1}}],[\"playground\",{\"0\":{\"51\":1},\"1\":{\"51\":1}}],[\"pattern\",{\"1\":{\"90\":1}}],[\"parat\",{\"1\":{\"97\":1}}],[\"parameters<t\",{\"1\":{\"97\":1}}],[\"parameters<typeof\",{\"1\":{\"97\":1}}],[\"parameters<type>的实现如下\",{\"1\":{\"97\":1}}],[\"parameters<type>的返回值会包括函数的参数名\",{\"1\":{\"97\":1}}],[\"parameters<type>主要用于从外部模块提供的函数类型中\",{\"1\":{\"97\":1}}],[\"parameters<type>从函数类型type里面提取参数类型\",{\"1\":{\"97\":1}}],[\"parameters<never>\",{\"1\":{\"97\":1}}],[\"parameters<any>\",{\"1\":{\"97\":1}}],[\"parameters<function>\",{\"1\":{\"97\":1}}],[\"parameters<string>\",{\"1\":{\"97\":1}}],[\"parameters<<t>\",{\"1\":{\"97\":1}}],[\"parameters<\",{\"1\":{\"97\":4}}],[\"parseint\",{\"1\":{\"75\":1}}],[\"partial<t>\",{\"1\":{\"98\":1,\"102\":1}}],[\"partial<type>的实现如下\",{\"1\":{\"98\":1}}],[\"partial<type>返回一个新类型\",{\"1\":{\"98\":1}}],[\"partial<a>\",{\"1\":{\"98\":1}}],[\"partial\",{\"1\":{\"18\":1}}],[\"partial^r\",{\"1\":{\"18\":1}}],[\"page\",{\"1\":{\"26\":1}}],[\"图片引入\",{\"1\":{\"28\":1}}],[\"图片增强\",{\"0\":{\"20\":1}}],[\"标签为\",{\"1\":{\"27\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"26\":1}}],[\"标题和页面信息\",{\"1\":{\"6\":1}}],[\"日\",{\"1\":{\"27\":1}}],[\"月\",{\"1\":{\"27\":1}}],[\"年\",{\"1\":{\"27\":1}}],[\"的非空值都属于object的子类型\",{\"1\":{\"94\":1}}],[\"的返回值类型\",{\"1\":{\"89\":2}}],[\"的形式\",{\"1\":{\"82\":1}}],[\"的行为是\",{\"1\":{\"70\":1}}],[\"的特殊性\",{\"0\":{\"70\":1}}],[\"的对象类型也有大写object和小写object两种\",{\"1\":{\"67\":1}}],[\"的8种类型之中\",{\"1\":{\"65\":1}}],[\"的基本类型\",{\"1\":{\"64\":1}}],[\"的属性值\",{\"1\":{\"60\":1}}],[\"的类型\",{\"1\":{\"96\":1}}],[\"的类型是\",{\"1\":{\"71\":3}}],[\"的类型设计\",{\"1\":{\"64\":1}}],[\"的类型使用symbol表示\",{\"1\":{\"59\":1}}],[\"的类型系统是动态的\",{\"1\":{\"44\":1}}],[\"的类型系统非常弱\",{\"1\":{\"44\":1}}],[\"的运行结果\",{\"1\":{\"58\":1}}],[\"的值\",{\"1\":{\"58\":1}}],[\"的值不会影响到另一个数据仓库\",{\"1\":{\"36\":1}}],[\"的概念\",{\"1\":{\"58\":1}}],[\"的顶层类型\",{\"1\":{\"57\":1}}],[\"的全集\",{\"1\":{\"57\":1}}],[\"的参数不能是一个值的运算式\",{\"1\":{\"75\":1}}],[\"的参数变量x和y\",{\"1\":{\"56\":1}}],[\"的参数num的类型是number\",{\"1\":{\"49\":1}}],[\"的意义\",{\"1\":{\"56\":1}}],[\"的命令行\",{\"1\":{\"52\":1}}],[\"的原因\",{\"1\":{\"45\":1}}],[\"的作用\",{\"1\":{\"44\":1}}],[\"的主要功能是为\",{\"1\":{\"44\":1}}],[\"的超集\",{\"1\":{\"42\":1}}],[\"的功能\",{\"1\":{\"42\":1}}],[\"的提升\",{\"0\":{\"39\":1}}],[\"的存储量最大也只有5m\",{\"1\":{\"35\":1}}],[\"的\",{\"1\":{\"26\":1,\"27\":1,\"52\":1}}],[\"helperfunctions\",{\"1\":{\"106\":1}}],[\"helperthisvalue\",{\"1\":{\"106\":1}}],[\"hello\",{\"1\":{\"43\":1,\"44\":2,\"45\":5,\"56\":3,\"57\":3,\"60\":2,\"65\":1,\"66\":6,\"71\":2,\"73\":1,\"76\":1,\"106\":1,\"108\":2,\"109\":2,\"110\":2,\"111\":2}}],[\"https\",{\"1\":{\"71\":3}}],[\"hi\",{\"1\":{\"68\":1,\"69\":1}}],[\"hope\",{\"1\":{\"27\":1}}],[\"h1\",{\"1\":{\"26\":2}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"flags\",{\"1\":{\"90\":1}}],[\"female\",{\"1\":{\"72\":1}}],[\"found\",{\"1\":{\"115\":1}}],[\"for\",{\"1\":{\"60\":3}}],[\"foo\",{\"1\":{\"44\":4,\"49\":1,\"50\":1,\"56\":3,\"57\":2,\"60\":4,\"68\":1,\"69\":1,\"71\":2,\"73\":3,\"75\":1}}],[\"false\",{\"1\":{\"59\":1,\"72\":1}}],[\"f\",{\"1\":{\"58\":4,\"85\":1}}],[\"fn\",{\"1\":{\"58\":1}}],[\"find\",{\"1\":{\"45\":1}}],[\"first\",{\"1\":{\"26\":1,\"97\":1}}],[\"func\",{\"1\":{\"37\":5}}],[\"function>\",{\"1\":{\"91\":2,\"92\":1}}],[\"function\",{\"1\":{\"36\":8,\"37\":4,\"43\":1,\"45\":1,\"49\":1,\"50\":1,\"56\":1,\"58\":2,\"75\":1,\"81\":1,\"85\":1,\"86\":2,\"93\":1,\"96\":1,\"97\":1,\"105\":1,\"106\":2}}],[\"frac\",{\"1\":{\"18\":4}}],[\"frontmatter\",{\"1\":{\"3\":1,\"6\":1,\"11\":4,\"26\":1,\"27\":1}}],[\"mutable<t>\",{\"1\":{\"100\":1}}],[\"multi\",{\"1\":{\"82\":1}}],[\"messege\",{\"1\":{\"45\":1}}],[\"message\",{\"1\":{\"45\":1,\"90\":1}}],[\"myage\",{\"1\":{\"75\":1}}],[\"my\",{\"1\":{\"36\":1}}],[\"math\",{\"1\":{\"74\":1,\"104\":1}}],[\"male\",{\"1\":{\"72\":1}}],[\"map\",{\"1\":{\"35\":1}}],[\"markdown\",{\"0\":{\"9\":1,\"10\":1,\"11\":1,\"12\":1},\"1\":{\"9\":2,\"10\":3,\"11\":1,\"12\":3,\"13\":2,\"14\":1,\"26\":3,\"27\":1,\"28\":2,\"29\":2},\"2\":{\"24\":1}}],[\"ms\",{\"1\":{\"27\":1}}],[\"more\",{\"1\":{\"25\":1}}],[\"上面代码中\",{\"1\":{\"91\":1,\"94\":1,\"100\":1,\"102\":1}}],[\"上面这种写法也可以\",{\"1\":{\"86\":1}}],[\"上面这五种原始类型的值\",{\"1\":{\"65\":1}}],[\"上面命令使用了noimplicitany编译选项进行编译\",{\"1\":{\"56\":1}}],[\"上面命令中\",{\"1\":{\"52\":1}}],[\"上面命令运行了\",{\"1\":{\"52\":1}}],[\"上面示例会报错\",{\"1\":{\"75\":1,\"86\":1}}],[\"上面示例是合法的\",{\"1\":{\"45\":1}}],[\"上面示例中\",{\"1\":{\"43\":2,\"44\":1,\"45\":2,\"49\":2,\"50\":1,\"52\":2,\"56\":6,\"57\":6,\"58\":3,\"60\":4,\"66\":1,\"71\":1,\"73\":1,\"81\":1,\"89\":1,\"93\":2,\"95\":2,\"96\":1,\"97\":2,\"99\":2,\"100\":1,\"101\":2,\"103\":1,\"106\":2}}],[\"上面的代码在\",{\"1\":{\"44\":1}}],[\"上面的例二\",{\"1\":{\"44\":1}}],[\"上面的例一\",{\"1\":{\"44\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"上一篇\",{\"1\":{\"3\":1}}],[\"201>\",{\"1\":{\"91\":1,\"92\":1}}],[\"200\",{\"1\":{\"91\":1,\"92\":2}}],[\"2020\",{\"1\":{\"27\":1}}],[\"255\",{\"1\":{\"83\":3}}],[\"25\",{\"1\":{\"82\":1}}],[\"23\",{\"1\":{\"82\":1}}],[\"24\",{\"1\":{\"70\":2,\"82\":1}}],[\"2\",{\"1\":{\"19\":1,\"36\":1,\"44\":2,\"56\":1,\"68\":1,\"69\":1,\"79\":2,\"81\":3,\"82\":1,\"83\":3,\"86\":4}}],[\"计划\",{\"1\":{\"19\":2}}],[\"random>\",{\"1\":{\"104\":1}}],[\"random\",{\"1\":{\"74\":1}}],[\"rainbowcolor\",{\"1\":{\"72\":1}}],[\"required<t>\",{\"1\":{\"102\":1}}],[\"required<type>的实现如下\",{\"1\":{\"102\":1}}],[\"required<type>返回一个新类型\",{\"1\":{\"102\":1}}],[\"required<a>\",{\"1\":{\"102\":1}}],[\"record<k\",{\"1\":{\"101\":1}}],[\"record<keys\",{\"1\":{\"101\":3}}],[\"record<\",{\"1\":{\"101\":3}}],[\"red\",{\"1\":{\"74\":2,\"83\":1}}],[\"readonlyarray<t>\",{\"1\":{\"103\":1}}],[\"readonlyarray<type>的实现如下\",{\"1\":{\"103\":1}}],[\"readonlyarray<type>用来生成一个只读数组类型\",{\"1\":{\"103\":1}}],[\"readonlyarray<string>\",{\"1\":{\"103\":1}}],[\"readonlyarray<number>\",{\"1\":{\"81\":1}}],[\"readonly表示去除属性的只读标志\",{\"1\":{\"100\":1}}],[\"readonly<partial<person>>\",{\"1\":{\"100\":1}}],[\"readonly<t>\",{\"1\":{\"100\":2}}],[\"readonly<type>可以与partial<type>结合使用\",{\"1\":{\"100\":1}}],[\"readonly<type>的实现也可以写成下面这样\",{\"1\":{\"100\":1}}],[\"readonly<type>的实现如下\",{\"1\":{\"100\":1}}],[\"readonly<type>不会改变这一点\",{\"1\":{\"100\":1}}],[\"readonly<type>返回一个新类型\",{\"1\":{\"100\":1}}],[\"readonly<a>\",{\"1\":{\"100\":1}}],[\"readonly<\",{\"1\":{\"84\":1}}],[\"readonly<number\",{\"1\":{\"81\":1}}],[\"readonly\",{\"1\":{\"60\":1,\"81\":3,\"84\":1,\"100\":4,\"103\":2}}],[\"repl\",{\"1\":{\"52\":4}}],[\"result\",{\"1\":{\"45\":1}}],[\"returntype<never>\",{\"1\":{\"104\":1}}],[\"returntype<any>\",{\"1\":{\"104\":1}}],[\"returntype<function>\",{\"1\":{\"104\":1}}],[\"returntype<boolean>\",{\"1\":{\"104\":1}}],[\"returntype<<t>\",{\"1\":{\"104\":1}}],[\"returntype<\",{\"1\":{\"104\":6}}],[\"returntype<type>的实现如下\",{\"1\":{\"104\":1}}],[\"returntype<type>提取函数类型type的返回值类型\",{\"1\":{\"104\":1}}],[\"returntype<typeof\",{\"1\":{\"97\":1,\"104\":2}}],[\"returnt\",{\"1\":{\"97\":1}}],[\"return\",{\"1\":{\"37\":2,\"43\":1,\"45\":1,\"49\":1,\"50\":1,\"56\":1,\"96\":1,\"105\":1,\"106\":1}}],[\"removeitem\",{\"1\":{\"36\":1}}],[\"regexp\",{\"1\":{\"35\":1,\"93\":1}}],[\"regarded\",{\"1\":{\"26\":1}}],[\"r\",{\"1\":{\"18\":3,\"57\":1,\"93\":2,\"96\":2,\"104\":2}}],[\"right\",{\"1\":{\"18\":3}}],[\"^\",{\"1\":{\"18\":1}}],[\"^i\",{\"1\":{\"18\":1}}],[\"^r\",{\"1\":{\"18\":2}}],[\"ide\",{\"1\":{\"45\":2}}],[\"if\",{\"1\":{\"37\":1,\"57\":2,\"58\":2,\"74\":1,\"75\":1,\"76\":1,\"85\":1}}],[\"isarray>\",{\"1\":{\"104\":1}}],[\"is\",{\"1\":{\"36\":2}}],[\"instancetype<\",{\"1\":{\"93\":1}}],[\"instancetype<never>\",{\"1\":{\"93\":1}}],[\"instancetype<new\",{\"1\":{\"93\":1}}],[\"instancetype<any>\",{\"1\":{\"93\":1}}],[\"instancetype<function>\",{\"1\":{\"93\":1}}],[\"instancetype<functionconstructor>\",{\"1\":{\"93\":1}}],[\"instancetype<string>\",{\"1\":{\"93\":1}}],[\"instancetype<type>的实现如下\",{\"1\":{\"93\":1}}],[\"instancetype<type>提取构造函数的返回值的类型\",{\"1\":{\"93\":1}}],[\"instancetype<typeof\",{\"1\":{\"93\":1}}],[\"instancetype<t>的返回值就是这些构造函数的实例类型\",{\"1\":{\"93\":1}}],[\"instancetype<t>的参数都是\",{\"1\":{\"93\":1}}],[\"instancetype<regexpconstructor>\",{\"1\":{\"93\":1}}],[\"instancetype<errorconstructor>\",{\"1\":{\"93\":1}}],[\"install\",{\"1\":{\"52\":1}}],[\"infer\",{\"1\":{\"90\":1,\"93\":1,\"96\":2,\"97\":1,\"104\":1,\"105\":1}}],[\"intersection\",{\"1\":{\"73\":1}}],[\"interface\",{\"1\":{\"60\":1,\"95\":2,\"97\":2,\"98\":1,\"99\":2,\"100\":2,\"102\":1,\"103\":1,\"106\":1}}],[\"indexeddb\",{\"0\":{\"35\":1},\"1\":{\"35\":2}}],[\"in\",{\"1\":{\"26\":1,\"98\":1,\"99\":1,\"100\":3,\"101\":1,\"102\":2}}],[\"i\",{\"1\":{\"18\":1,\"29\":1}}],[\"i+1\",{\"1\":{\"18\":1}}],[\"i=1\",{\"1\":{\"18\":1}}],[\"it\",{\"1\":{\"12\":2}}],[\"+readonly\",{\"1\":{\"100\":1}}],[\"+readonly就表示增加只读标志\",{\"1\":{\"100\":1}}],[\"+\",{\"1\":{\"18\":1,\"29\":1,\"43\":1,\"45\":1,\"49\":1,\"52\":2,\"56\":1,\"57\":3,\"68\":1,\"69\":1,\"71\":3,\"102\":1,\"106\":1}}],[\"y会报错\",{\"1\":{\"106\":1}}],[\"y是可选属性\",{\"1\":{\"100\":1}}],[\"y\",{\"1\":{\"18\":2,\"44\":6,\"56\":7,\"59\":2,\"60\":3,\"61\":2,\"70\":1,\"71\":5,\"86\":2,\"90\":2,\"93\":1,\"95\":6,\"98\":2,\"99\":6,\"100\":2,\"102\":2,\"106\":1}}],[\"y^\",{\"1\":{\"18\":2}}],[\"last\",{\"1\":{\"97\":1}}],[\"lastexectime\",{\"1\":{\"37\":4}}],[\"line\",{\"1\":{\"64\":3,\"66\":1,\"67\":1}}],[\"length\",{\"1\":{\"57\":1,\"85\":1,\"103\":1}}],[\"let命令声明的变量\",{\"1\":{\"61\":2}}],[\"let\",{\"1\":{\"37\":3,\"45\":1,\"49\":1,\"50\":1,\"56\":6,\"57\":8,\"58\":4,\"59\":2,\"60\":1,\"61\":3,\"66\":2,\"68\":2,\"69\":1,\"70\":4,\"71\":3,\"72\":5,\"73\":2,\"74\":1,\"75\":2,\"76\":2,\"79\":4,\"81\":2,\"83\":2,\"106\":2}}],[\"left\",{\"1\":{\"18\":3}}],[\"lowercase<a>\",{\"1\":{\"109\":1}}],[\"lowercase<stringtype>将字符串的每个字符转为小写\",{\"1\":{\"109\":1}}],[\"localforage\",{\"1\":{\"36\":6}}],[\"localstorage\",{\"1\":{\"35\":1,\"36\":1}}],[\"logerror\",{\"1\":{\"106\":3}}],[\"log\",{\"1\":{\"18\":2,\"36\":8,\"45\":1}}],[\"===\",{\"1\":{\"57\":3,\"58\":2,\"59\":1,\"60\":2,\"75\":1,\"85\":1}}],[\"=>\",{\"1\":{\"37\":2,\"52\":1,\"57\":1,\"68\":1,\"69\":1,\"90\":4,\"91\":2,\"92\":2,\"93\":4,\"96\":3,\"97\":7,\"104\":10,\"105\":1,\"106\":2}}],[\"=\",{\"1\":{\"18\":1,\"36\":2,\"37\":6,\"44\":8,\"45\":4,\"50\":1,\"52\":1,\"56\":9,\"57\":16,\"58\":3,\"59\":2,\"60\":20,\"61\":6,\"66\":6,\"68\":8,\"69\":6,\"70\":9,\"71\":10,\"72\":4,\"73\":3,\"74\":8,\"75\":8,\"76\":4,\"79\":6,\"80\":2,\"81\":10,\"82\":1,\"83\":15,\"84\":2,\"86\":3,\"89\":3,\"90\":10,\"91\":8,\"92\":8,\"93\":12,\"94\":7,\"95\":5,\"96\":2,\"97\":12,\"98\":2,\"99\":5,\"100\":6,\"101\":4,\"102\":3,\"103\":2,\"104\":13,\"105\":2,\"106\":2,\"108\":2,\"109\":2,\"110\":2,\"111\":2}}],[\"t>\",{\"1\":{\"97\":1,\"99\":1,\"101\":1,\"104\":1}}],[\"t7\",{\"1\":{\"91\":1}}],[\"t6\",{\"1\":{\"91\":1,\"92\":1,\"94\":1,\"104\":1}}],[\"t5\",{\"1\":{\"91\":1,\"92\":1,\"94\":1,\"97\":1,\"104\":1}}],[\"t4\",{\"1\":{\"91\":1,\"92\":1,\"94\":1,\"97\":1,\"104\":1}}],[\"t3\",{\"1\":{\"83\":1,\"90\":1,\"91\":1,\"92\":1,\"94\":1,\"95\":1,\"97\":1,\"99\":1,\"104\":1}}],[\"t2\",{\"1\":{\"83\":1,\"90\":4,\"91\":1,\"92\":1,\"93\":2,\"94\":1,\"95\":1,\"97\":3,\"99\":1,\"104\":4}}],[\"tuple\",{\"1\":{\"83\":4}}],[\"t是最底层数组成员的类型\",{\"1\":{\"82\":1}}],[\"t\",{\"1\":{\"75\":1,\"76\":4,\"84\":2,\"90\":2,\"91\":2,\"92\":3,\"93\":4,\"94\":2,\"95\":2,\"96\":4,\"97\":2,\"98\":3,\"99\":2,\"100\":7,\"101\":4,\"102\":5,\"103\":1,\"104\":3,\"105\":2}}],[\"t1\",{\"1\":{\"75\":1,\"83\":1,\"90\":4,\"91\":1,\"92\":1,\"93\":2,\"94\":1,\"95\":1,\"97\":3,\"99\":1,\"104\":4}}],[\"t0\",{\"1\":{\"75\":1}}],[\"trim\",{\"1\":{\"57\":1}}],[\"true\",{\"1\":{\"45\":1,\"56\":1,\"57\":1,\"68\":1,\"69\":1,\"70\":1,\"72\":1,\"75\":1,\"76\":1,\"83\":1}}],[\"twice\",{\"1\":{\"52\":2}}],[\"tohex>\",{\"1\":{\"96\":1,\"105\":1}}],[\"tohex\",{\"1\":{\"96\":1,\"105\":1}}],[\"tofixed\",{\"1\":{\"56\":1}}],[\"top\",{\"1\":{\"56\":1}}],[\"tostring\",{\"1\":{\"49\":1,\"50\":1,\"70\":1,\"96\":1,\"105\":1}}],[\"toc\",{\"1\":{\"6\":1}}],[\"ts文件里面\",{\"1\":{\"107\":1}}],[\"tsconfig\",{\"1\":{\"70\":1}}],[\"tsc\",{\"1\":{\"56\":1,\"70\":1}}],[\"ts\",{\"0\":{\"52\":1},\"1\":{\"42\":1,\"52\":14,\"56\":1,\"70\":1}}],[\"ts简介\",{\"0\":{\"41\":1}}],[\"type>的实现如下\",{\"1\":{\"101\":1}}],[\"type>的第一个参数a\",{\"1\":{\"101\":1}}],[\"type>返回一个对象类型\",{\"1\":{\"101\":1}}],[\"types\",{\"1\":{\"72\":1,\"73\":1}}],[\"typescript数组有一个根本特征\",{\"1\":{\"79\":1}}],[\"typescript实际上会关闭这个变量的类型检查\",{\"1\":{\"56\":1}}],[\"typescript\",{\"0\":{\"51\":1},\"1\":{\"42\":4,\"43\":3,\"44\":5,\"45\":7,\"46\":4,\"49\":2,\"50\":5,\"51\":2,\"52\":9,\"56\":13,\"57\":2,\"58\":4,\"59\":1,\"60\":2,\"61\":1,\"64\":3,\"66\":1,\"67\":1,\"70\":2,\"71\":3,\"73\":1,\"75\":4,\"76\":1,\"79\":1,\"80\":2,\"81\":1,\"82\":1,\"83\":1,\"85\":1,\"86\":3,\"93\":1,\"94\":1,\"106\":2,\"107\":2},\"2\":{\"47\":1,\"53\":1,\"62\":1,\"77\":1,\"87\":1,\"112\":1}}],[\"typeof命令的参数不能是类型\",{\"1\":{\"75\":1}}],[\"typeof运算符只可能返回八种结果\",{\"1\":{\"75\":1}}],[\"typeof运算符和instanceof运算符这几种\",{\"1\":{\"57\":1}}],[\"typeof\",{\"0\":{\"75\":1},\"1\":{\"57\":2,\"58\":2,\"60\":1,\"75\":16}}],[\"type\",{\"0\":{\"74\":1,\"118\":1},\"1\":{\"43\":1,\"56\":1,\"58\":1,\"73\":2,\"74\":7,\"75\":5,\"76\":2,\"79\":4,\"83\":8,\"84\":2,\"89\":3,\"90\":9,\"91\":8,\"92\":8,\"93\":10,\"94\":7,\"95\":5,\"96\":2,\"97\":12,\"98\":2,\"99\":5,\"100\":4,\"101\":4,\"102\":3,\"104\":13,\"105\":2,\"108\":2,\"109\":2,\"110\":2,\"111\":2}}],[\"typedarray\",{\"1\":{\"35\":1}}],[\"timeoutid\",{\"1\":{\"37\":6}}],[\"title\",{\"1\":{\"26\":3}}],[\"thistype<type>的实现就是一个空接口\",{\"1\":{\"106\":1}}],[\"thistype<type>不返回类型\",{\"1\":{\"106\":1}}],[\"thistype<\",{\"1\":{\"106\":1}}],[\"thistype<helperthisvalue>\",{\"1\":{\"106\":1}}],[\"thisparametertype<type>的实现如下\",{\"1\":{\"105\":1}}],[\"thisparametertype<type>提取函数类型中this参数的类型\",{\"1\":{\"105\":1}}],[\"thisparametertype<typeof\",{\"1\":{\"105\":1}}],[\"thisparametertype<t>\",{\"1\":{\"96\":1,\"105\":1}}],[\"this\",{\"1\":{\"37\":3,\"96\":4,\"105\":3,\"106\":4}}],[\"throw\",{\"1\":{\"58\":1}}],[\"throttle\",{\"1\":{\"37\":1}}],[\"three\",{\"1\":{\"36\":1}}],[\"then\",{\"1\":{\"36\":4}}],[\"the\",{\"1\":{\"26\":1}}],[\"tex\",{\"0\":{\"18\":1}}],[\"导致每一个原始类型的值都有包装对象和字面量两种情况\",{\"1\":{\"66\":1}}],[\"导致报错\",{\"1\":{\"60\":1}}],[\"导致其他变量出错\",{\"1\":{\"56\":1}}],[\"导致用户在使用时遇到错误\",{\"1\":{\"43\":1}}],[\"导入文件\",{\"0\":{\"17\":1}}],[\"导航栏\",{\"1\":{\"3\":1,\"6\":1}}],[\"16\",{\"1\":{\"96\":1,\"105\":1}}],[\"127n\",{\"1\":{\"75\":1}}],[\"123\",{\"1\":{\"50\":1,\"56\":2,\"57\":2,\"68\":1,\"69\":1,\"72\":1,\"80\":2}}],[\"123和456这两个值\",{\"1\":{\"43\":1}}],[\"1337\",{\"1\":{\"75\":1}}],[\"1的类型\",{\"1\":{\"71\":1}}],[\"10\",{\"1\":{\"57\":1}}],[\"100\",{\"1\":{\"56\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"1\",{\"1\":{\"16\":1,\"18\":1,\"19\":1,\"27\":2,\"29\":2,\"36\":1,\"43\":1,\"44\":4,\"56\":4,\"57\":5,\"65\":1,\"68\":3,\"69\":3,\"71\":3,\"75\":1,\"79\":2,\"81\":7,\"82\":1,\"83\":4,\"86\":4,\"103\":2}}],[\"查看详情\",{\"1\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1}}],[\"选项卡\",{\"0\":{\"15\":1}}],[\"插件\",{\"1\":{\"14\":1}}],[\"插件来实现\",{\"1\":{\"12\":1}}],[\"关于这些扩展\",{\"1\":{\"13\":1}}],[\"对象类型a不存在键名z\",{\"1\":{\"99\":1}}],[\"对象类型a中不存在属性z\",{\"1\":{\"95\":1}}],[\"对象有什么属性\",{\"1\":{\"44\":1}}],[\"对五种原始类型分别提供了大写和小写两种类型\",{\"1\":{\"66\":1}}],[\"对于开发者没有指定类型\",{\"1\":{\"56\":1}}],[\"对于这些存储方式\",{\"1\":{\"35\":1}}],[\"对于本地话存储\",{\"1\":{\"35\":1}}],[\"对于\",{\"1\":{\"28\":1}}],[\"对\",{\"1\":{\"13\":1,\"42\":1}}],[\"为什么never类型可以赋值给任意其他类型呢\",{\"1\":{\"58\":1}}],[\"为了避免这种情况\",{\"1\":{\"70\":1}}],[\"为了区分这两种情况\",{\"1\":{\"66\":1}}],[\"为了解决这个问题\",{\"1\":{\"60\":1}}],[\"为了解决any类型\",{\"1\":{\"57\":1}}],[\"为了保持与集合论的对应关系\",{\"1\":{\"58\":1}}],[\"为了适配以前老的\",{\"1\":{\"56\":1}}],[\"为了丰富文档写作\",{\"1\":{\"13\":1}}],[\"为编译器和开发工具提供更多的验证和帮助\",{\"1\":{\"43\":1}}],[\"为每个\",{\"1\":{\"11\":1}}],[\"来解析\",{\"1\":{\"12\":1}}],[\"扩展运算符与成员数量\",{\"0\":{\"86\":1}}],[\"扩展运算符\",{\"1\":{\"83\":1,\"86\":1}}],[\"扩展\",{\"0\":{\"12\":1,\"13\":1},\"1\":{\"13\":1}}],[\"了解详情\",{\"1\":{\"11\":1}}],[\"请看下面的\",{\"1\":{\"44\":1}}],[\"请使用绝对链接\",{\"1\":{\"28\":1}}],[\"请阅读\",{\"1\":{\"11\":1,\"13\":1}}],[\"请先阅读\",{\"1\":{\"10\":1}}],[\"中使用\",{\"1\":{\"29\":1}}],[\"中设置页面信息\",{\"1\":{\"27\":1}}],[\"中设置页面标题\",{\"1\":{\"26\":1}}],[\"中的第一个\",{\"1\":{\"26\":1}}],[\"中的\",{\"1\":{\"13\":1}}],[\"中很重要的一个概念\",{\"1\":{\"11\":1}}],[\"中自定义它们\",{\"1\":{\"6\":1}}],[\"是object类型的简写形式\",{\"1\":{\"68\":1}}],[\"是es2015\",{\"1\":{\"59\":1}}],[\"是不会报错的\",{\"1\":{\"56\":1}}],[\"是在开发阶段报错\",{\"1\":{\"43\":1}}],[\"是微软公司开发的一种基于\",{\"1\":{\"42\":1}}],[\"是一个非官方的\",{\"1\":{\"52\":1}}],[\"是一个基于javascript的面向对象数据库\",{\"1\":{\"35\":1}}],[\"是一种底层的api\",{\"1\":{\"35\":1}}],[\"是\",{\"1\":{\"11\":1,\"83\":1}}],[\"配置\",{\"0\":{\"11\":1}}],[\"演示一下类型系统的作用\",{\"1\":{\"43\":1}}],[\"演示\",{\"1\":{\"10\":1}}],[\"和never\",{\"1\":{\"90\":1,\"97\":1}}],[\"和bigint\",{\"1\":{\"65\":1,\"66\":1}}],[\"和自动补全功能\",{\"1\":{\"45\":1}}],[\"和\",{\"0\":{\"70\":1},\"1\":{\"10\":1,\"27\":1,\"66\":5}}],[\"介绍\",{\"0\":{\"10\":1},\"1\":{\"10\":1,\"11\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"29\":1}}],[\"你需要创建并编写\",{\"1\":{\"9\":1}}],[\"你可以存储非字符串类型\",{\"1\":{\"36\":1}}],[\"你可以将图片和\",{\"1\":{\"28\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"28\":1}}],[\"你可以在这个环境中输入\",{\"1\":{\"52\":1}}],[\"你可以在\",{\"1\":{\"26\":1,\"27\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"6\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"9\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"3\":1}}],[\"文件夹的图片\",{\"1\":{\"28\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"28\":1}}],[\"文件生成页面\",{\"1\":{\"9\":1}}],[\"文章标题列表\",{\"1\":{\"6\":1}}],[\"夜间模式按钮\",{\"1\":{\"6\":1}}],[\"主题扩展了更多\",{\"1\":{\"14\":1}}],[\"主题扩展\",{\"0\":{\"14\":1}}],[\"主题也带有以下元素\",{\"1\":{\"6\":1}}],[\"主要是在一些类型运算之中\",{\"1\":{\"58\":1}}],[\"主要有以下几个限制\",{\"1\":{\"57\":1}}],[\"主要目的是在软件开发过程中\",{\"1\":{\"43\":1}}],[\"主要从\",{\"1\":{\"9\":1}}],[\"主要功能与配置演示\",{\"0\":{\"1\":1}}],[\"布局包括\",{\"1\":{\"6\":1}}],[\"布局\",{\"0\":{\"6\":1},\"2\":{\"8\":1}}],[\"布局与功能禁用\",{\"0\":{\"3\":1}}],[\"禁用\",{\"2\":{\"5\":1}}],[\"禁用了如下功能\",{\"1\":{\"3\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"29\":1}}],[\"页面内容\",{\"0\":{\"28\":1}}],[\"页面标题\",{\"0\":{\"26\":1},\"1\":{\"26\":1}}],[\"页面配置\",{\"0\":{\"25\":1},\"1\":{\"27\":1},\"2\":{\"31\":1}}],[\"页面引入配置\",{\"1\":{\"11\":1}}],[\"页面信息\",{\"0\":{\"27\":1},\"1\":{\"3\":1}}],[\"页脚\",{\"1\":{\"3\":1,\"6\":1}}],[\"评论\",{\"1\":{\"3\":1,\"6\":1}}],[\"链接\",{\"1\":{\"3\":1}}],[\"贡献者\",{\"1\":{\"3\":1,\"6\":1}}],[\"路径导航\",{\"1\":{\"3\":1,\"6\":1}}],[\"侧边栏\",{\"1\":{\"3\":1,\"6\":1}}],[\"本页面就是一个示例\",{\"1\":{\"3\":1}}]],\"version\":2}}")).map(([e,t])=>[e,jn(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:n,options:s,id:r}})=>{const o=An[n];e==="suggest"?self.postMessage([e,r,Et(t,o,s)]):e==="search"?self.postMessage([e,r,vt(t,o,s,"max")]):self.postMessage({suggestions:[e,r,Et(t,o,s)],results:[e,r,vt(t,o,s,__SLIMSEARCH_SORT_STRATEGY__)]})};
//# sourceMappingURL=index.js.map
